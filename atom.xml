<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>安阳</title>
  
  <subtitle>You Deserve Better.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://JohnneyAnn.github.io/"/>
  <updated>2018-03-29T05:44:54.638Z</updated>
  <id>http://JohnneyAnn.github.io/</id>
  
  <author>
    <name>安 阳</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL-ONLY_FULL_GROUP_BY模式问题</title>
    <link href="http://JohnneyAnn.github.io/2018/03/29/MySQL-ONLY_FULL_GROUP_BY%E6%A8%A1%E5%BC%8F%E9%97%AE%E9%A2%98/"/>
    <id>http://JohnneyAnn.github.io/2018/03/29/MySQL-ONLY_FULL_GROUP_BY模式问题/</id>
    <published>2018-03-29T05:55:33.747Z</published>
    <updated>2018-03-29T05:44:54.638Z</updated>
    
    <content type="html"><![CDATA[<p>数据库刷在mysql5.5版本上没有问题，但刷在5.7上之后出了这个问题，导致页面请求出错。</p><a id="more"></a><p>错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Expression #1 of SELECT list is not in GROUP BY clause and contains </div><div class="line">nonaggregated column &apos;dept.label&apos; which is not functionally </div><div class="line">dependent on columns in GROUP BY clause; this is incompatible with </div><div class="line">sql_mode=only_full_group_by</div></pre></td></tr></table></figure><p>问题原因：</p><p>MySQL 5.7.5及以上功能依赖检测功能。默认情况下启用ONLY_FULL_GROUP_BY SQL模式，MySQL将拒绝选择列表，HAVING条件或ORDER BY列表的查询引用在GROUP BY子句中既未命名的非集合列，也不在功能上依赖于它们。（5.7.5之前，MySQL没有检测到功能依赖关系，默认情况下不启用ONLY_FULL_GROUP_BY）。</p><p>解决方案：<br>（关闭ONLY_FULL_GROUP_BY模式）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">set</span> @@global.sql_mode </div><div class="line">=<span class="string">'STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'</span>;</div><div class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</div><div class="line">（以前是ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION，可用<span class="keyword">select</span> @@global.sql_mode查出来）</div></pre></td></tr></table></figure><p>我在执行过程中报了错，说没有NO_AUTO_CREATE_USER，于是把这个也给去了，之后页面就正常显示了。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">set</span> @@global.sql_mode</div><div class="line">=<span class="string">'STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION'</span>;</div></pre></td></tr></table></figure></p><p>这里作为个人笔记，其他解决办法及介绍可移步：<br><a href="https://blog.csdn.net/MissWwg/article/details/77719085" target="_blank" rel="external">Error Code: 1055. Expression #2 of SELECT list is not in GROUP BY clause and contains nonaggregated</a></p><hr><p>2018.03.29 13:44</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据库刷在mysql5.5版本上没有问题，但刷在5.7上之后出了这个问题，导致页面请求出错。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://JohnneyAnn.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="mysql" scheme="http://JohnneyAnn.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>这里有一座孤岛</title>
    <link href="http://JohnneyAnn.github.io/2018/03/25/%E8%BF%99%E9%87%8C%E6%9C%89%E4%B8%80%E5%BA%A7%E5%AD%A4%E5%B2%9B/"/>
    <id>http://JohnneyAnn.github.io/2018/03/25/这里有一座孤岛/</id>
    <published>2018-03-24T16:09:43.228Z</published>
    <updated>2018-03-24T16:09:43.228Z</updated>
    
    <content type="html"><![CDATA[<p>我像一座孤岛，四面环水，孤立无援。喜欢热闹，也喜欢安静，可能就是这样一个矛盾的人。</p><a id="more"></a><p>去年三月份来到南京实习，带着心中的目标，想着一切都在变好的道路上前行着，可是后来我把人弄丢了，也差点丢了自己。现在又三月了，一年的时间一切变化的很快，也不知是什么有了变化。 </p><p>开始朋友圈一条动态，“流浪在合肥街头”，我没有关注“流浪”两个字，倒是“合肥”这两个字眼让我感触颇深，于是，就把想到的写在这里。或许不是因为我算半个合肥人而感触远离家乡的悲愁，而是因为在合肥生活的大学四年。 </p><p>至少在大学之前，合肥对我来说也是个陌生的城市，在某种程度上与来南京的陌生并无不同。我来到这两个城市都有着一定的目的性，是为了维持某种关系，说起来有些媚俗，但似乎也是人之常情。如今，这些都不存在，我还在南京。 </p><p>南京相较于合肥那自然是好的，差就差在少了那四年的境遇。倒是有高中好友也在南京，除此好像确实没有任何熟悉的事物，你不能让他把所有的周末都放置在你这里，每个人很多关系需要去维护，人不就一致处在维持关系的状态中。就当是我一个人在这。我喜欢周末出去走走，这是我喜欢热闹的表现，我冲进人群，听到别人的谈话，我走到一些有趣的地方，看不一样的场景，这些听起来都是那么得有意境，我将其放到微博、朋友圈，难免让别人误会。而这恰巧体现出我的孤立无援，渴望获得别人的认可，实话说出来有显的如此低俗。甚至，当我正在进行这些事的时候，连我自己都骗了，当时这些事情完成，静下心来去回想，逛着的三两小时，我竟一句话没有说，如空气一般，飘着飘着，看似与所有人都接触，而没有人能真切感知，何等悲哀。 </p><p>现在住的离公司远了，每天一个多小时的车程，大家都说这人怕是傻了，这不找罪受呢。当你做某个决定时，你一定想好了一万个理由来与朋友说服。在此，我想赋予这个决定形而上的意义。摧残人的不是肉体，而是精神。相较于被孤独这个情感的摧残我更希望是来自“跋涉”这个物理上的摧残。梁文道在《我执》里说到“一旦又较稳当的晚上，才发现自己竟又恢复了独处的生活”，这于就是路程的遥远与加班能让我独处的时间短点，不失为一件乐事。连续几个星期晚上都加班，其中有一两个晚上没有加班，回来竟觉得百般不适，是对工作的痴迷？对加班的痴迷？我可能还没有那么高尚，只是回来太安静了。同事说我有闲情雅致，回来还看看书，我将自己摆在文艺好学的位置表示出对知识的渴望，实则我并不知道我能干嘛，只能借此打发时间，或许解决孤独之外还能获得意外之喜。来回的路程给了看书的更多的时间，在其他物质需求满足不了的情况下，或许能够满足精神需求，抑或第三层次需求。如此看来，我还没啥，该知道的我都知道。 </p><p>如果不幸，独处的时间降临，除了靠这些精神食粮来充实，我还会和朋友打打电话开视屏，这是我维系异地朋友关系的方式，也是我满足自身需求的一种表现。我想我也没找到其他更好的方式，毕业之后或者说工作之时，大家都为生活所迫，又是处在不同的城市，常见已是种奢侈。进来得朋友一决定，颇为钦佩。他离开合肥来到杭州，合肥的工作不喜欢是一个理由，还有个理由是她在杭州，他说他对很多事都后知后觉，现在想去争取一下。冲动么？冲动。对么？个人觉得无法评判。我钦佩的是他想做就去做的态度，我做不到。我劝他大家都是后知后觉的，去杭州自然不会那么顺利，但决定做了自然就无法更改了，那就别谈什么懊悔。关于对错，这事还没玩，你刚做决定怎么知道对错，只有等你为这个决定付出了行动得到了结果你才知道对错，可从另一个方面来看，贯穿于整件事，对错早已没有了意义。如果后来真的要评个对错，那一定得让它是对的，后来觉得是错的，那一定是你没做好，没有给这个决定赋予实际有意义的行动。 </p><p>跟他聊完，我又想抽自己几个嘴巴子。大道理一堆一堆的，说得跟自己是个明白人似的，可实际自己的生活都过不好。我们都处在某个伤愁的境遇，我也好，他也好，其他的朋友也罢，谁都有烦心的事。我似乎与其他人又有些不同，我只能跟另一个我诉说，如同他们跟我诉说一样。也是我自己在作祟，不愿提及这些，我还能在这里发发牢骚，想与他们聊点开心的事，聊些曾经的高中、大学生活，想想都会情不自禁的笑。 </p><p>是啊，多么有趣啊。大学毕业一年了，高中五年了，人也丢失了很多，留下来实属不易，那该是我们的财富。你会感叹时间的迅速，也感叹时间的恐怖，在不同的阶段，不同的时间，人都不一样，此刻写博客的我与写博客之前的我也不一样，你看，变化多快。好在，我们总是在适应这个世界，每个阶段的想法、做法都是为了去让自己活得更好。希望大家都好，至少没有我这样的孤独。 </p><p>牢骚发完，今晚的独处到这里就结束了，接下来想去做个梦，会有很多人在，是能够去接触的，能够被他人感知的，这样或许还能赶上你们还没有过去的今天。 </p><p>明天见。 </p><hr><p>写于 2018.3.25 00:06</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我像一座孤岛，四面环水，孤立无援。喜欢热闹，也喜欢安静，可能就是这样一个矛盾的人。&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://JohnneyAnn.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="记录" scheme="http://JohnneyAnn.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
      <category term="随笔" scheme="http://JohnneyAnn.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>简约至上</title>
    <link href="http://JohnneyAnn.github.io/2018/03/18/%E7%AE%80%E7%BA%A6%E8%87%B3%E4%B8%8A/"/>
    <id>http://JohnneyAnn.github.io/2018/03/18/简约至上/</id>
    <published>2018-03-18T14:53:44.826Z</published>
    <updated>2018-03-18T14:53:44.826Z</updated>
    
    <content type="html"><![CDATA[<p>追求简单易用是人类的本性。</p><a id="more"></a><p>人们害怕复杂，遇到复杂的事情，如果不是一定要做的，自然没必要纠缠下去，如果你的产品使用起来很复杂，等于设置了很高的门槛，那用户凭什么用你的？ </p><p>用户分三种：专家型用户，随意型用户，主流用户。 </p><p>专家型用户：愿意探索你的产品或服务，并提出各种改进建议。（看来我是专家型用户，从微信读书软件或者邮件都给微信读书团队发过使用体验，还写的很认真，虽然只有邮件收到了回复） </p><p>随意型用户：可能使用过类似的产品，他们有兴趣使用更高级更复杂的产品，但一定不要使全新的。 </p><p>主流用户：不会因为技术而使用你的产品，二是为了完成某项任务。 </p><p>在使用一段时间后，不同类型的用户并不会转变为另一种，即使用了很多年。产品应该满足与主流用户，忽略专家型用户。 </p><h1 id="简约四策略一：删除"><a href="#简约四策略一：删除" class="headerlink" title="简约四策略一：删除"></a>简约四策略一：删除</h1><p>简化设计最明显的方式就是删除不必要的功能。砍掉残缺的功能，如果某功能实现的并不理想就应当删除它，大多数人觉得删除不完整的功能会导致已经付出的时间和努力白白浪费，但实际上这部分功能的成本是不可能收回来的，需要判断的是它能够返回几分作用以及保留它额外导致多少成本，避免陷入“沉没成本误区”。除功能外，对内容也需要做精简，如多此一举的内容提示，冗余的文字等。 </p><h1 id="简约四策略二：组织"><a href="#简约四策略二：组织" class="headerlink" title="简约四策略二：组织"></a>简约四策略二：组织</h1><p>组织往往是简化设计的最快捷的方式。对已有内容进行有效的组织分区，使其成为清晰的层次结构。将各项组织到7加减2个块中，理论上这是人的大脑瞬间能够记住的最大数目。 </p><h1 id="简约四策略三：隐藏"><a href="#简约四策略三：隐藏" class="headerlink" title="简约四策略三：隐藏"></a>简约四策略三：隐藏</h1><p>隐藏适用于不常用但不能少的功能，如个性化设置，高级用法，需要时候的提示等。用户希望每个环节能够像讲故事一样层层展开，顺着故事线自然会跟着一步步地去做，从而完成用户操作。因此，保证用户在前进的过程中能够遇到提示，但不要挡住用户的去路。 </p><h1 id="简约四策略四：转移"><a href="#简约四策略四：转移" class="headerlink" title="简约四策略四：转移"></a>简约四策略四：转移</h1><p>在设备间的转移，将根据设备进行功能分配，将合适的功能放到合适的设备上，投影设备遥控器就能很好的体现，遥控器上只有最基本的按钮，其他操作会放到显示屏上分区展示供用户选择。向用户转移，让用户与计算机各自去做自己最擅长的事（计算机擅长计算，人喜欢控制结果），用户指挥，计算机操作，就会给人简单的感觉。 </p><p>简单会提升用户体验，更用户留下足够的想象空间。 </p><p>书名：《简约至上：交互设计四策略》</p><hr><p>写于 2018.3.18 22:51</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;追求简单易用是人类的本性。&lt;/p&gt;
    
    </summary>
    
      <category term="书籍分享" scheme="http://JohnneyAnn.github.io/categories/%E4%B9%A6%E7%B1%8D%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="读书笔记" scheme="http://JohnneyAnn.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计" scheme="http://JohnneyAnn.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>上瘾</title>
    <link href="http://JohnneyAnn.github.io/2018/03/12/%E4%B8%8A%E7%98%BE/"/>
    <id>http://JohnneyAnn.github.io/2018/03/12/上瘾/</id>
    <published>2018-03-12T15:59:50.792Z</published>
    <updated>2018-03-12T15:59:50.792Z</updated>
    
    <content type="html"><![CDATA[<p>好的产品一定建基与深刻的艺术品味与心理学原理。</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>好的产品一定建基与深刻的艺术品味与心理学原理。</p><p>书中给出上瘾模型（the Hook Model）四个阶段：触发—行动—多变的酬赏—投入。如序言所说，这四个阶段可以对应到心理学中亲密关系的四个阶段，第一步“触发”，可以对应亲密关系中的“相识、吸引”。第二步“行动”，可以对应亲密关系中的“接触、了解”。第三步“多变的酬赏”，可以对应亲密关系中的“惊喜、甜蜜”。第四步“投入”，可以对应亲密关系中的“热恋、维护”。</p><h2 id="1-触发"><a href="#1-触发" class="headerlink" title="1.触发"></a>1.触发</h2><p>触发可促使用户采取行动，分为外部触发和内部处罚。外部触发通过将信息渗透在用户生活的各个方面来引导他们采取下一步行动，如醒目的按钮，朋友的推荐等。内部触发通过用户记忆存储中的各种关联来提醒他们采取下一步行动，如负面情绪等。</p><h2 id="2-行动"><a href="#2-行动" class="headerlink" title="2.行动"></a>2.行动</h2><p>福格行为模型可以用公式来呈现，即B=MAT，B代表行为，M代表动机，A代表能力，T代表触发，想要人们完成特定的行为三者缺一不可。<br>动机：人们的动机不外乎三种，第一种，追求快乐，逃避痛苦；第二种，追求希望，逃避恐惧；第三种，追求认同，逃避排斥。<br>能力：时间、金钱、体力、脑力、社会偏差、非常规性等六个因素会对用户的能力产生影响。<br>触发：请参见第一条。</p><h2 id="3-多变的酬赏"><a href="#3-多变的酬赏" class="headerlink" title="3.多变的酬赏"></a>3.多变的酬赏</h2><p>多变的酬赏因为其多变性、神秘性吸引着用户。这里包含三种类型：社交酬赏，猎物酬赏，自我酬赏。社交酬赏是指人们产品中通过与他人的互动而获取的人际奖励。猎物酬赏是指人们从产品中获得的具体资源或信息。自我酬赏是指人们从产品中体验到的操纵感、成就感和终结感。</p><h2 id="4-投入"><a href="#4-投入" class="headerlink" title="4.投入"></a>4.投入</h2><p>投入阶段主要与用户对未来酬赏的期待有关。用户对产品投入的越多，则会对该产品形成便好。因为我们会往往高估自己的劳动成果，尽力和自己过去的行为保持一致，避免认知失调。你极力去获取的东西，倘若你对其排斥，你将会陷入认知失调，来怀疑自己之前的行为，为了解除这种失调，最简单的方式就是去接受它。用户投入可通过加载下一次触发的方式反复进入上瘾模型循环。</p><h1 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h1><p>我为什么前段时间因为抖音没睡好觉。</p><h2 id="1-触发-1"><a href="#1-触发-1" class="headerlink" title="1.触发"></a>1.触发</h2><p>朋友的朋友圈分享，面对面的推荐，自己无聊时间的打发。</p><h2 id="2-行动-1"><a href="#2-行动-1" class="headerlink" title="2.行动"></a>2.行动</h2><p>动机：追求认同、追求快乐<br>能力：有个手机还不能下个软件么（也有时间去看，不过确实耽误了很多时间）</p><h2 id="3-多变的酬赏-1"><a href="#3-多变的酬赏-1" class="headerlink" title="3.多变的酬赏"></a>3.多变的酬赏</h2><p>社交酬赏：我发了几条抖音，收到了些许的赞还有些正面评论，还能看到想看的朋友的抖音<br>猎物酬赏：抖音的查看方式是我在之前没有看过的，不像大多数短视频软件，采用宫格方式展示一部分资源供用户看封面选择查看，采取的上下滑动的方式，每次只看一条，你不知道下一条会是什么，这种神秘性吸引了我，我也更想看到更多的资源。<br>自我酬赏：抖音内的视频在早期走的是技术流，可能也因此其有质量的视频偏多，不像某手，我也去学了些里面的拍摄技巧，最终拍摄成品获得极大的满足感。</p><h2 id="4-投入-1"><a href="#4-投入-1" class="headerlink" title="4.投入"></a>4.投入</h2><p>抖音内容几乎全为UGC，增加了其多变性，另外用户每次发布UGC后，都会不断的再次打开app，查看自己是否获得新的反馈，从而再次进入上瘾模型，我也不例外，也贡献了几条。</p><p>虽然最近理智让我减少了查看抖音的时间，只是偶尔打开看一看，但早期的沦陷也让我反思。最近可能也是因为没有再进行投入，自然也没有新的反馈，能够获得的只是猎物酬赏，在观看了大部分资源之后，多变性也在减少，于是抖音对我的外部触发偏少了，更多的是自己无聊的时候打开刷两条。但在某种程度上，这依然是与部分朋友们的谈资。</p><p>书名：《上瘾：让用户养成使用习惯的四大产品逻辑》</p><hr><p>写于 2018.3.12 23:57</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好的产品一定建基与深刻的艺术品味与心理学原理。&lt;/p&gt;
    
    </summary>
    
      <category term="书籍分享" scheme="http://JohnneyAnn.github.io/categories/%E4%B9%A6%E7%B1%8D%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="读书笔记" scheme="http://JohnneyAnn.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="随笔" scheme="http://JohnneyAnn.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>王阳明知行合一</title>
    <link href="http://JohnneyAnn.github.io/2018/03/09/%E7%8E%8B%E9%98%B3%E6%98%8E%E7%9F%A5%E8%A1%8C%E5%90%88%E4%B8%80/"/>
    <id>http://JohnneyAnn.github.io/2018/03/09/王阳明知行合一/</id>
    <published>2018-03-09T15:45:31.079Z</published>
    <updated>2018-03-09T15:45:31.079Z</updated>
    
    <content type="html"><![CDATA[<p>知是行之始，行是知之成。</p><a id="more"></a><p>1.圣学多为存天理，去人欲。每个人都有欲望，至少落地之后就有生的欲望，那为什么要去人欲呢？这里的人欲为“过”或“不及”，对于像正常的生的欲望，不属于人欲而是天理。在心学里也可以这么理解，良知指引你的就是天理，违背良知的就是人欲。 </p><p>2.心即理，理在心中，但需事上练。心学认为，理在我们心中，我们生下来就心中就有了理，我们不需要像外界获得理，但需要致良知，将埋没在我们心中的理挖掘出来。 </p><p>3.知行合一，知是行之始，行是知之成。在空间上知与行不可分割，在时间上知是行之始，行是知之成。知行合一就是一件事的开始与终结，不可有始无终，二者缺一不可。当你进行某件事时，定是为了满足某种需求，同样，有了做一件事的心，才会去做这件事。 </p><p>4.四句教：无善无恶心之体，有善有恶意之动，至善至恶是良知，为善去恶是格物。 </p><p>心学将良知必做太阳，我们为了应付这个复杂的世界，人欲如同乌云挡灾了太阳面前。我们经常会遇到一些事，脑海里有两个想法，做了可能会有损他人（良知、太阳），不做又损害了自己的利益（人欲、乌云），我们陷入纠结，是接受良知的指引还是满足自己的欲望？心学告诉我们要致良知，遇到乌云就用力拨开。我们可以看到心学上良知是至高无上的，乌云岂能与太阳抗衡！以前都会觉得我们由两个小人组成，一个是善良的，一个是恶毒的，二者打一架，谁赢了听谁的，这个想法的一出现明显将此二人处于平级，这显然是不合适的。 </p><p>心学在伦理关系上可谓是无懈可击，像是我们不用像外界学习就知道孝为先，但抛开伦理关系放于现实生活中就显得有点鸡肋了，像是我要去学编程，我心里知道编程怎么玩么？于是，有了这样一个解释，心这个东西太伟大，可以这么说，用心去学编程，那就自然发现了这个理，我们寻求的是心中用心的理。 </p><p>看到知行合一，首先想到的是言行一致，于是拿起了这本书。本想着可能如其他中国哲学类书似的，说着理论而难以感知，这本书说了王阳明知行合一的四个例子，写的太有趣了，好不严肃，但确实很搞笑啊，例子中举的小例子差点没笑死我（我又想起王阳明早期学理学对着竹子格物的时候- -）。 </p><hr><p>写于 2018.3.9</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;知是行之始，行是知之成。&lt;/p&gt;
    
    </summary>
    
      <category term="书籍分享" scheme="http://JohnneyAnn.github.io/categories/%E4%B9%A6%E7%B1%8D%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="读书笔记" scheme="http://JohnneyAnn.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="随笔" scheme="http://JohnneyAnn.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>To Kill A Mockingbird</title>
    <link href="http://JohnneyAnn.github.io/2018/03/07/%E6%9D%80%E6%AD%BB%E4%B8%80%E5%8F%AA%E7%9F%A5%E6%9B%B4%E9%B8%9F/"/>
    <id>http://JohnneyAnn.github.io/2018/03/07/杀死一只知更鸟/</id>
    <published>2018-03-07T14:14:53.058Z</published>
    <updated>2018-03-07T14:14:53.058Z</updated>
    
    <content type="html"><![CDATA[<p>一本获得1960年普利策文学奖的书，一本55年来美国人说地位仅次于圣经的书。</p><a id="more"></a><p>书中以一个小女孩斯考特的视角描述上世纪30年代美国南部小镇发生的事，或许是因为作者哈珀•李也有一个律师爸爸，或许是因为她的律师爸爸也为黑人打过官司，或许就是描述作者自己小时候，才能写出如此好的著作。<br>我们的世界充满了偏见，哪怕是到现在还没有避免，这可能也是这部作品被称为经典的原因。</p><p>To Kill A Mockingbird旨在揭露美国社会矛盾和批判司法体系，书中黑人汤姆被诬陷强奸一名白人女性阿耶尔，虽然阿帝克斯使用了所有能开释一个自由人的法律手段去拯救汤姆，可还是没能说服陪审团相信汤姆，最终汤姆绝望的逃跑而被警察射杀，种族歧视与司法体系的无能造就了悲剧的发生。正如书中所说，阿耶尔本没有犯罪，只是违反了被致以崇高敬意的社会伦理——勾引一位年轻的黑人男性，可是她为了掩瞒自己的过失而想让汤姆——一个活生生的人消失，这是不可原谅的。知更鸟只唱歌给我们听，什么坏事也不做，汤姆就是一只被种族歧视与司法体系的无能杀死的知更鸟，然而事实上在当时的社会背景下，阿耶尔的父亲BOB也是一只知更鸟，最终他为自己的恶行付出生命，但真正杀死他的是无法摆脱的贫穷和无知。 </p><p>大多数人对书中人物分析的都很透彻了，于是我想找一个不怎么被拉出来的人物，斯考特的姑姑亚历山德拉。亚历山德拉也很好的体现出偏见这个概念，她刻意的体现出自己的家族与别人的不同，带着有色眼镜去看待他人，认为家族背景决定了其他家族一定是什么样的人。如果说偏见是属于情感成分，那在认知成分上表现的就是刻板印象，亚历山德拉将某一家族概括化，没有考虑家族成员之间实际的差异，最终导致了行为成分歧视。偏见是全人类共同的问题，带给我们的伤害是无穷的，心理学上有个概念叫“自证预言”，它指出我们会根据我们的刻板印象而决定我们将如何对待对方，而这种对待方式又会导致那个人的行为与我们最初的预期一致，使得这一预期成为现实，而事实上他可能跟我们想的完全相反，但由于你这样对他，他以牙还牙产生了现在的结局，偏见会影响我们看到的世界。另外，我觉得亚历山德拉也有米兰•昆德拉所说的媚俗，媚俗的人指定一个不能接受的范围，并排斥这个范围的一切，而亚历山德拉的能接受的范围就是她那社会上层的标准，在认同生命存在的前提下盲目的执行着，并且希望她们家族也奉行着她的标准，对斯考特的要求就能够体现。书中说到塞西尔复述他妈妈的话：衔苹果游戏不卫生，会的传染病。当斯考特就此事问了姑姑，亚历山德拉说持这种观点的一般都是社会上想往上爬的人。我想这些都能够体现出媚俗。我们也处在媚俗之中，不可避免，谈论媚俗、拒绝媚俗本身也是媚俗。 </p><p>下面想分享一些书中的我喜欢的句子，挑几个出来吧。</p><p>这送给正在阅读的各位，当然我知道你们肯定很喜欢阅读。</p><blockquote><p>阅读就像一个人的呼吸，即使不喜欢也不能不做。</p></blockquote><p>我还喜欢阿帝克斯的教导，以后也得做个这样的爸爸。 </p><blockquote><p>道理很简单，不能因为我们在此之前已经失败了一百年，就认为我们没有理由去争取胜利。但是在我能和别人过得去之前，我首先要和自己过得去。有一种东西不能遵循从众原则，那就是人的良心。 </p></blockquote><p>卡波尼说的也很有道理，有些话不必说出口，智者不言。 </p><blockquote><p>没有必要把你懂的所有东西都说出来。那很不淑女——再说，人们不喜欢他们身边有人比他们懂得更多。那会让他们很恼火。你说得再正确，也改变不了这些人。除非他们自己想学，否则一点办法也没有。你要么闭上嘴巴，要么就使用他们的语言。 </p></blockquote><p>“醉鬼”雷蒙德在帮助看不惯自己生活方式的人找到一个合适的理由。 </p><blockquote><p>这样的确不诚实，但对人们会有帮助。芬奇小姐，我其实不怎么喝酒，可是你知道吗，他们永远永远也不可能理解：我之所以这样生活，是因为这就是我想要的生活方式。 </p></blockquote><p>阿帝克斯与斯考特的对话告诉我们，我们无法改变他人，但我们能做好我们自己。 </p><blockquote><p>“那么，恨希特勒可以吗？” ,“不可以。”他说，“不应该恨任何人。” </p></blockquote><p>就写到这，推荐一波。  </p><p>看完书还看了下电影，黑白的，两个小时的电影无法将书中所描述的全都展现出来，但看看还是不错的，书的旨意已经表达清楚了，毕竟也是在1963年获得三项好莱坞奖的电影。 </p><hr><p>写于 2018.2.27  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一本获得1960年普利策文学奖的书，一本55年来美国人说地位仅次于圣经的书。&lt;/p&gt;
    
    </summary>
    
      <category term="书籍分享" scheme="http://JohnneyAnn.github.io/categories/%E4%B9%A6%E7%B1%8D%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="读书笔记" scheme="http://JohnneyAnn.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="随笔" scheme="http://JohnneyAnn.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>思考与存在</title>
    <link href="http://JohnneyAnn.github.io/2018/02/16/%E6%80%9D%E8%80%83%E4%B8%8E%E5%AD%98%E5%9C%A8/"/>
    <id>http://JohnneyAnn.github.io/2018/02/16/思考与存在/</id>
    <published>2018-02-15T16:16:11.793Z</published>
    <updated>2018-02-15T16:16:11.793Z</updated>
    
    <content type="html"><![CDATA[<p>我是谁？我从哪来？到哪去？我们对这几个问题似乎很清楚，因为对于特定环境下，这几个问题很好回答；我们又对这几个问题很模糊，我们很难找到答案，因为对于一个体来说，我们为何存在于这个世界，我们的存在对这个世界有什么影响，我们处于这个世界而去思考这个世界，显然有点滑稽了。</p><a id="more"></a><p>亚里斯多德说：“那个自古以来就发问的问题，那个现在仍然要问的问题，那个将来永远要发问的问题，那个是我们永远不得安宁的问题就是：存在是什么？而这也是在问：本体是什么？”。有的时候觉得哲学家们好奇怪，老是去思考这些奇了古怪的问题，有时候又觉得哲学家们好厉害，能够比我们更高一层次去思考问题。如亚里士多德所说，问存在就是在问本体是什么，发现了这个问题，但并没有得到合理的解释，有人说：“认识你自己”，这好像也没有来解释，因为我们如何认识我们自己并没有个明确的答案。直到迪卡尔宣称：“我思故我在“，我比较认可这个结论，思考与存在是一体的，先思考才有存在的意义。</p><p>工作之后知道描述数据的数据是元数据，心理学的分析方法论中所说分析的分析成为元分析，那姑且这里也称思考的思考为元思考，哲学家们干的可能就是元思考的活。这里可以看到我们在数据、分析、思考上面只封装了一层，那是否还能在第二层上面再封装一层呢？思考的思考的思考，元元思考？可能不能了，如同数据、分析一样，当我们对元数据、元分析进行描述分析时，之前的元数据、元分析只能够被称为数据和分析了。刚刚的方向在很多情况下都是如此，在第一层次上我们得出的某个结论，会被高一层次的结论推翻，因此对于这个结论来说只有是或否两个结果，在某一个层次上为是，在更高一层次上则为否。佛教大乘的中道宗提出的“二谛义”可能也是这个意思。“二谛义”认为有普通意义的道理，即“俗谛”；有高级意义的道理，即“真谛”。它进一步认为，不仅有这两种道理，而且都存在于不同的层次上。于是低一层次的真谛，在高一层次就只是俗谛。把书中的例子再举出来：</p><blockquote><p>我们面前的桌子，要表明它正在停止存在，并不需要毁掉它。事实上，它无时无刻不是正在停止其存在。其原因在于，你开始毁桌子，你所想毁的桌子已经停止存在了。此一刻的桌子不再是前一刻的桌子了。桌子只是看着好像前一刻的桌子。</p></blockquote><p>佛曰：不可说。因为我们只能够到达第二层次的真谛，按照佛家此宗，到第三层次否定了第二层次，一切都否定了，包括否定这个“这个否定一切”，自然无法到达第三层次，也就什么都不能说了。这个结论是我能够接受的，我觉得到了第三层次，其实也是真的说不了什么了，我们到达不了。</p><p>个体的思考有着一定的局限性，我们作为旁观者能够去思考我们之外的事物，我们会去评论无关于我们的事，有时能够给出较为理性的解释。但如果我们身处其中，我们的答案可能就不完善了。身处其中往大一点可以说到世界、宇宙，如前文所说，我们就是宇宙的一部分啊，而且我们并不等同于宇宙，还不能称为反思，人类虽是一个个有思想的个体，但放到宇宙的尺度上，等同于无思想，想象一下有一天你的手突然在思考本体是什么的时候，多么滑稽。再往小了说，我们思考我们内在，我们都认为我们思考是我们的大脑，大脑是“我”的一部分，让大脑去思考“我”是什么，也是很滑稽的，也是很恐怖的，因为“我”（个人认为“我”是一种意识形态，并非实体）并非我的大脑，我的大脑所想并不是“我”所想，它并不代表我，那么它打出这些字是为了何种企图，就道不出了，细思极恐（大脑微微一笑：就是要吓死你（大脑近而再笑：说出来就是看不起你（大脑再再笑：给大家开个玩笑…）））。</p><p>声明：以上只是自己在意淫，并不代表正确性。</p><p>伴随着这篇博客的结束，农历年也结束了。在此住大家新年…赚大钱，不说快乐了，快乐太俗了，有钱就快乐（/手动摊手）。</p><hr><p>完结于 2018.2.16 00:05 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我是谁？我从哪来？到哪去？我们对这几个问题似乎很清楚，因为对于特定环境下，这几个问题很好回答；我们又对这几个问题很模糊，我们很难找到答案，因为对于一个体来说，我们为何存在于这个世界，我们的存在对这个世界有什么影响，我们处于这个世界而去思考这个世界，显然有点滑稽了。&lt;/p&gt;
    
    </summary>
    
      <category term="书籍分享" scheme="http://JohnneyAnn.github.io/categories/%E4%B9%A6%E7%B1%8D%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="读书笔记" scheme="http://JohnneyAnn.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="随笔" scheme="http://JohnneyAnn.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>DNS_PROBE_POSSIBLE问题</title>
    <link href="http://JohnneyAnn.github.io/2018/02/08/DNS_PROBE_POSSIBLE%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://JohnneyAnn.github.io/2018/02/08/DNS_PROBE_POSSIBLE错误代码解决办法/</id>
    <published>2018-02-08T07:04:29.178Z</published>
    <updated>2018-02-08T07:04:29.178Z</updated>
    
    <content type="html"><![CDATA[<p>Windows系统打开网页时显示DNS_PROBE_POSSIBLE错误代码解决办法。<br><a id="more"></a></p><ul><li><p>1.打开cmd</p></li><li><p>2.输入netsh winsock reset命令</p></li><li><p>3.重启电脑  shudown -r</p></li></ul><p>Tips:</p><p>shutdown 命令说明：</p><ul><li><code>-s</code> 关机</li><li><code>-r</code> 重启</li><li><code>-t</code> 时间，后面是数字是你要设置的秒数</li><li><code>-a</code> 取消命令，如果要取消定时命令可以  <code>shutdown -a</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Windows系统打开网页时显示DNS_PROBE_POSSIBLE错误代码解决办法。&lt;br&gt;
    
    </summary>
    
      <category term="电脑问题" scheme="http://JohnneyAnn.github.io/categories/%E7%94%B5%E8%84%91%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="windows" scheme="http://JohnneyAnn.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序开发遇到的问题</title>
    <link href="http://JohnneyAnn.github.io/2018/02/04/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://JohnneyAnn.github.io/2018/02/04/微信小程序开发遇到的问题/</id>
    <published>2018-02-04T10:10:07.233Z</published>
    <updated>2018-02-04T10:10:07.233Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客记录学习开发微信小程序时遇到的问题。此次学习开发的是一个功能小程序，提供电影信息模块及文章阅读模块。下面简单说下概况以及开发过程中遇到的问题。在以后开发新的项目时会持续更新，想做点有自己想法的东西。</p><a id="more"></a><h1 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h1><h2 id="小程序啊"><a href="#小程序啊" class="headerlink" title="小程序啊"></a>小程序啊</h2><p>截止写这篇博客，此学习项目算是结束了，小程序是个及其容易上手的新东西。如小程序开发者文档中所说：</p><blockquote><p>小程序提供了丰富的基础组件给开发者，开发者可以像搭积木一样，组合各种组件拼合成自己的小程序。</p></blockquote><p>确实如此，我们不需要像开发web页面一样，使用各种标签来实现我们自己的组件，我们只需要想搭积木似的，即可完成基本的页面。当然你得会一点CSS和JS。另外，我们更改页面数据，不再需要像jquery那样先获取dom再去修改，小程序借鉴了AngularJs等数据驱动的框架，页面通过数据驱动再真正实现了MV分离。本来想介绍下小程序一个页面包含哪些文件，每个文件的作用等等，后来发现还不如去看小程序的官方文档，就罢了。</p><p>但个人觉得理解小程序应当就把它当作一个原生的App，只是它的操作系统是微信。如同安卓一样，页面的组件需要配置在xml里面，只是在小程序里面组件的样式(wxss)与组件的定义(wxml)是分离的.同样，安卓程序里面每个页面称为activity，在小程序里面则被称为Page（这个可能更好理解），有页面则肯定需要页面的跳转，安卓使用趋势，小程序则使用路由。当然，小程序还有自己的生命周期，知道的生命周期才知道什么时候该做什么样的事。对比看来，是很好理解的，带着开发原生app的思想用开发web的方法去开发小程序。</p><p>小程序还在成长阶段，它的思想是很好的，如张小龙所说好的程序是用完即走的，那么微信小程序是个好的产品，微信不是。我还喜欢它的slogan,”再小的个体，也有自己的品牌”，这个真是无法抗拒。于是，以今天这个项目作为入门，鉴于思想，一起成长。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>下面说说这个学习项目的概况。电影信息主要展示从豆瓣获取的数据，包含正在热映、即将上映和豆瓣Top250模块，可查看电影的基本信息；文章阅读提供文章列表以及查看详情，由于小程序中没有DOM，因此不能够像web那样可以定义好样式，将标签等信息直接存入数据库，另外小程序虽现在支持web-view，但没有对个人开发者开放，因此也不能够直接跳转到我的博客地址。于是，目前界面渲染的数据，都不是从数据库中获取，是将数据写入某个js中，假装作为本地数据库，所以看到的都是假的，只是实现了页面功能，另外还加了个音乐播放。</p><h1 id="Q-amp-A-and-Tips"><a href="#Q-amp-A-and-Tips" class="headerlink" title="Q&amp;A and Tips"></a>Q&amp;A and Tips</h1><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>Q1:编写完app.json配置后(页面注册)编译出现脚本错误或者未正确调用 Page()<br>A1:新编写的页面中没有自动生成内容，需要添加Page({})，否则会报错，同样的问题还出现在json文件中，如果json文件为空，应当填入{}，在目前的开发工具中已经会提示哪里错了</p><p>Q2:控制台出现<code>Now you can provide attr &quot;wx:key&quot; for a &quot;wx:for&quot; to improve performance.</code>警告，警告不处理不影响程序运行，但看着就很奇怪<br>A2:在<code>wx:for</code>后面添加<code>wx:key=&quot;key&quot;</code>或<code>wx:for-index=&#39;idx&#39;</code>可消除警告</p><blockquote><p>当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。–开发者文档</p></blockquote><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>tip1:标签中若有bool类型，都应该采用数据绑定，如`vertical="{{false}}"`若使用<code>vertical=&quot;false&quot;</code>，小程序仍会解析成true</p><p>tip2:使用`wx:if={{condition}`来控制组件显隐（<code>wx:elif wx:else</code>）</p><p>tips3:小程序中绑定事件使用bind或catch，如<code>catchtap=&#39;onItemTap&#39;</code>，其中bind为冒泡事件，catch为非冒泡事件</p><p>tips4:使用require引入js，需将当前js导出为模块`module.exports = {}`（这个如同AMD）</p><p>tip5:require引入js只能使用相对路径，这个不知后期会不会有更改</p><p>tip6:小程序总是会读取data对象下面的属性值来做数据绑定，这个动作执行是在onLoad事件执行之后发生的</p><p>tip7:像template的传入数据时，在数据前加…(扩展运算符…)可平铺对象，可直接使用对象的属性，而不用那对象进行点，如：`{{item}}`则使用item.title，`{{…item}}`则直接使用title</p><p>tip8:data-xxx 称为自定义属性,必须用data-开头，后面跟自定义名称,在js中获取时，如点击事件则使用<code>event.currentTarget.dataset.data-xxx</code>获取。当data后的自定义名称为驼峰式时，会被全部转换成小写，当采用连字符时将被转换成驼峰式，如：data-postId转换为postid, data-post-id转换为postId</p><p>tip9:小程序缓存的上限最大不能超过10兆</p><p>tip10:点击事件event对象下：target:指的是当前点击的组件，currentTarget指的是事件捕获的组件(处理冒泡事件是很有帮助)</p><p>tip11:使用上滑加载更多应当使用scroll-view，还要给scroll-view一个高度才能触底加载更多，小程序中没有dom，应当采用更新数据模型来渲染页面，将新获得的数据追加到数据模型中进行数据驱动。</p><p>tip12:小程序从版本130400之后下拉刷新和scroll-view不可以同时使用，导致onPullDownRefresh事件函数无法执行的原因是页面里包含一个scroll-view组件。而scroll-view组件和onPullDownRefresh在130400版本里是冲突的。当我们在页面里滑动scroll-view时，只是滑动这个组件，不再可以触发onPullDownRefresh。因此换一种方法，放弃使用scroll-view，MINA在Page里还提供了一个onReachBottom事件，使用这个事件来监听页面上滑到底。将scroll-view组件换成view组件，并去掉了scroll-view组件原有的属性以及绑定事件，在js里提供onReachBottom，方法体与之前绑定的事件相同。<br>但更改后出现一个问题，上滑刷新时没有之前使用scroll-view顺滑，因此个人认为页面没有强下拉刷新需求时，可考虑去除这个功能。</p><p>tip13:input事件bindblur只可监听失焦，bindchange可监听失焦和键盘确定（回车，bindconfirm可监听键盘确定（回车)</p><hr><p>编辑与2018.2.4 17:00 初稿</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博客记录学习开发微信小程序时遇到的问题。此次学习开发的是一个功能小程序，提供电影信息模块及文章阅读模块。下面简单说下概况以及开发过程中遇到的问题。在以后开发新的项目时会持续更新，想做点有自己想法的东西。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://JohnneyAnn.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程问题" scheme="http://JohnneyAnn.github.io/tags/%E7%BC%96%E7%A8%8B%E9%97%AE%E9%A2%98/"/>
    
      <category term="学习" scheme="http://JohnneyAnn.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="小程序" scheme="http://JohnneyAnn.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>出•遇</title>
    <link href="http://JohnneyAnn.github.io/2018/01/28/%E5%87%BA%E2%80%A2%E9%81%87/"/>
    <id>http://JohnneyAnn.github.io/2018/01/28/出•遇/</id>
    <published>2018-01-28T04:18:05.997Z</published>
    <updated>2018-01-28T04:18:05.997Z</updated>
    
    <content type="html"><![CDATA[<p>《出•遇》</p><a id="more"></a><p>出，走出去<br>遇，遇见未知<br>这是今天的主题</p><p>冒雪前进<br>自诩为艺术献身<br>是为了遇见艺术<br>还是<br>我不说了<br>我就是这样的虚伪</p><p>雪很大<br>世界很美<br>大家都喜欢雪<br>却也拿着伞格挡<br>我就是这样的虚伪</p><p>我不懂艺术<br>该怎么评价<br>也不敢评价<br>生怕玷污了这幅画<br>我不说话了<br>我就是这样的虚伪</p><p>可能是把艺术看的太高了<br>孰不知<br>我们的生活就是艺术<br>如此触手可及<br>也就不那么虚伪了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《出•遇》&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://JohnneyAnn.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://JohnneyAnn.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="诗" scheme="http://JohnneyAnn.github.io/tags/%E8%AF%97/"/>
    
  </entry>
  
  <entry>
    <title>区块链-BlockChain(完结)</title>
    <link href="http://JohnneyAnn.github.io/2018/01/27/%E5%8C%BA%E5%9D%97%E9%93%BE-BlockChain/"/>
    <id>http://JohnneyAnn.github.io/2018/01/27/区块链-BlockChain/</id>
    <published>2018-01-27T03:25:17.726Z</published>
    <updated>2018-01-27T03:25:17.722Z</updated>
    
    <content type="html"><![CDATA[<p>最近大家可能被区块链的推送推的烦了，不只是“区块链”，还有这些名词：“炒币”、“挖矿”、“矿工”、“区块链”、“ICO”等。也许由于之前的勒索病毒的影响太大，使得它将用于其支付的比特币推向了白热化，各大媒体都去谈论比特币是什么，“区块链”技术渐渐从极客圈向大众圈扩散，加上比特币汇率的变化（截至写这篇博客BTC/CNY:86655.16），更让其走进了投资圈。我写这篇博客或许也是在蹭热点，但请往下看。</p><a id="more"></a><h1 id="为什么写这篇博客"><a href="#为什么写这篇博客" class="headerlink" title="为什么写这篇博客"></a>为什么写这篇博客</h1><h2 id="两片有意思的文章"><a href="#两片有意思的文章" class="headerlink" title="两片有意思的文章"></a>两片有意思的文章</h2><p>我想往常一样浏览着文章，看到一个标题《区块链微信》（发布于woshipm.com,作者@A.J.软软熊），看着着实有意思，大概是微信像是一系列账本，再结合区块链技术得到一个不一样的分布式程序，作者还取了个名字BWeChat（BlockChainWeChat,区块链微信）。有趣归有趣，但看不太懂，因为很多专业名词之前都没听过，也不知道为啥区块链微信会有这些东西，这只能去看看区块链是什么才能够明白一点，于是我想着该去了解一些再来看看，理解了肯定更有意思。</p><p>我大概是个猫奴，虽然我没有猫（我一定会有个猫的）。“云养猫”是之前网上为了调侃没有猫却喜欢猫而且还撸不到现实中猫的人，比如说我，这里套用“云”，因为我们这类人喜欢看猫的图片、动画、视频，都是别人的猫。你可能以为我跑题了，不，并没有，我是为了引出我接下来要说的事（知识点，记下）。上文说到的“云养猫”大概属于低层次“云养猫”，来说说区块链养猫吧。也就是看到的第二篇文章《区块链养猫，我们时代的一个不和谐的符号》（发布于woshipm.com,作者@joeycidic）,文中说到这是有Axiom Zen工作室开发的虚拟宠物养成社区游戏，玩家在区块链上买虚拟的猫，互相或者和别的玩家的猫进行繁殖，每只猫有256种基因，基于一定的算法，可以遗传到下一代。基因的组合和传递是不透明的，这吸引的玩家乐此不疲的买猫和生仔。太有趣了！我也要买一个！于是看了下价格，最贵的猫10万美元，均价130美元，我可能不适合这个游戏。文中介绍到这是一个有现金投资和收益的游戏，在用户能持续消费（生小猫）和交易（购买猫）的前提下，区块链猫变成了一种能产生现金流回报的资产。这片文章没过多说区块链的原理，包含哪些东西，而是主要来介绍这个游戏，因此比上一篇文章容易取看懂，这里介绍的多一点（或许是因为是说猫的我没刹住车），其实还有很多内容，这里就不赘述了，文末会放链接。</p><h2 id="一本区块链的书"><a href="#一本区块链的书" class="headerlink" title="一本区块链的书"></a>一本区块链的书</h2><p>想去完整的了解一个东西，得找到合适的渠道。于是找到了《区块链：定义未来金融与经济新格局》（作者：火币网 张健），这是一本深入浅出，科学严谨的区块链专业著作，张健是火币技术副总裁、国内领先的区块链查询及数据服务平台“Qukuai.com”创始人。想从网上找到合适的书籍并不容易，看完这本，还是比较喜欢的，这本书涉及的领域非常宽泛，对于技术的深究还得去多学习，但去了解个大概，这本书是再合适不过了。这篇博客所涉及的区块链介绍及应用大多来自这本书，因此可以看出是对这本书的整理，文末会放上写这篇博客的思维导图。或许我也该把博客名字改成“一文看懂区块链”来博得大家的眼球，这太放肆了，只能算的上名词解释，不敢造次，因为自己还没明白。这篇博客的定位是一篇读书记录、一篇书籍的推荐文、一篇满足自己好奇心的文章。</p><h2 id="微信公众号的推送"><a href="#微信公众号的推送" class="headerlink" title="微信公众号的推送"></a>微信公众号的推送</h2><p>这个模块是有顺序的，先看到有趣的文章，再去了解，最后是接收到关于区块链的公众号推送。乍一看，很想是AI智能推荐，你在看什么，我就给你推送什么（这里只是顺带吐槽）。我确认我使用的是两个不同的软件，不同的账号，二者没有任何关联，另外公众号的推送属于全投放，大多数阅读类公众号为提高阅读量，并不会将消息推送给特定用户群体，而且也不知道我平时干了啥，于是得出结论，是最近区块链过热了（以上说的都是屁话）。刚刚经过一波毫无意义的分析，得出了一个早就显现的结论，我们为作者（安阳）鼓个掌增加其创作的动力，然后作者准备说正文了。微信公众号推送的关于区块链的文章太多了，开始我也看，后来我发现大多就那几个版本，就说什么区块链技术、数字货币的本质，还会配上“一文看懂区块链”，“你真的了解区块链”等等等等的标题（这个上节有提到过，毕竟很多标题党都这么来欺骗无知的少年，我就被套路过不下N次），再尴尬的是好几个公众号（小规模）推送的内容是一样的，以阮一峰系列为主，因此看一两个就够了，别浪费自己时间。当然也不全是，有的知名的公众号还是会出一些分析报告，像是目前国内哪些公司使用区块链以及其应用，这些还是可以的。是真的被推烦了，就怕自己手贱再去点开，于是，我决定自己也要写一篇！然后点我自己的。如果能找到那些公众号的作者我就把他们拉个群然后把我的文章链接发给他，一天发两次，最好还能@全体。（突然扯了好多，我是要介绍区块链的男人啊！罪过罪过）</p><h1 id="区块链和其相关的概念"><a href="#区块链和其相关的概念" class="headerlink" title="区块链和其相关的概念"></a>区块链和其相关的概念</h1><h2 id="区块链的定义"><a href="#区块链的定义" class="headerlink" title="区块链的定义"></a>区块链的定义</h2><p>关于区块链的定义网上有很多了，这里抛几个。</p><blockquote><p>狭义来讲，区块链是一种按照时间顺序将数据区块以顺序相连的方式组合成的一种链式数据结构， 并以密码学方式保证的不可篡改和不可伪造的分布式账本。<br>广义来讲，区块链技术是利用块链式数据结构来验证与存储数据、利用分布式节点共识算法来生成和更新数据、利用密码学的方式保证数据传输和访问的安全、利用由自动化脚本代码组成的智能合约来编程和操作数据的一种全新的分布式基础架构与计算范式。–百度百科</p><p>区块链（这里特指比特币区块链）的本质是一种去中心化的记账系统，而比特币正是这个系统上承载的“以数字形式存在”的货币。 –《区块链：定义未来金融与经济新格局》（以下简称《区块链》）</p></blockquote><p>区块链或者说比特币什么时候出现的呢？这里有一个背景，2008年9月，金融危机在美国爆发并席卷全世界。同年10月31日下午，在一个普通的密码学机构邮件列表中，几百个成员均收到了自称是“中本聪”的人发送的电子邮件。他在邮件里描述了一个全新的，不依赖任何机构、政府，完全网络化的货币体系。一个月后，中本聪放出了比特币系统最原始的版本。</p><h2 id="去中心化、竞争记账、POW"><a href="#去中心化、竞争记账、POW" class="headerlink" title="去中心化、竞争记账、POW"></a>去中心化、竞争记账、POW</h2><p>区块链诞生了，不管从哪里看到的定义，都有一个核心的概念—去中心化。在我们现在的生活中，为了保证所记录的数据是唯一的，比如说账本，因此就导致了记账是一种天然的中心化行为。这样的例子还有很多，我们在办理某个事情的时候，经常需要开一些证明，证明我是我（公安局里证明）、证明我有这么多钱（银行系统），证明婚姻关系（民政局）等等，我们有很多第三方组织或机构来证明我们以及我们所拥有的存在，而这些不过只是数据库里的数据罢了。我们可以看到这些中心化的记录方式有显而易见的弱点：一旦这个中心出现问题，如被篡改、被损坏，整个系统就会面临危机乃至崩溃，到那时我们还存在么？因此我们能不能构建一个不依赖任何中心或者第三方但可靠的系统呢？事实上，这比想象的要复杂的多（以记账为例），账本数据存储要去中心化（所有的参与方都平等地拥有保存账本的能力），记账行为去中心化（参与方平等的拥有记录账务数据的权利）。这就出现了一个悖论，不同节点缺乏信任的前提下数据的一致性难以保证。</p><p>这个看似不可能解决的问题，由区块链解决了。从字面意思，区块链就是由区块组成的链条，《区块链》有一个比喻，如果区块链是一个账本，那么区块就相当于账本中的一页。当前时代负责记账的自然是计算机，每个计算机就是一个节点，每个节点竞争记账（以每个节点的计算能力来竞争记账权的机制），这就是区块链的架构设计。计算能力（算力）只能决定赢得的概率，就像你买多张彩票可以增加获奖的概率，但你不一定会中奖。区块链通过“工作量证明（Proof Of Work,POW）”来实现竞争记账，你完成了该做的工作量（一般是一个人人都可验证的结果），那你就可以记账了。</p><p>在中本聪的设计里引入竞争的同时解决了货币发行的问题，每轮竞争胜出并完成记账的节点会获得系统给予的比特币奖励。比特币生产总量被限制在2100万枚，总量一定，这个像是黄金开采过程，于是被人们称为“挖矿”，干这活的就是“矿工”了。</p><h2 id="共识机制与价值载体"><a href="#共识机制与价值载体" class="headerlink" title="共识机制与价值载体"></a>共识机制与价值载体</h2><p>有那么多的节点，在去中心化的结构中如何保证你的记录被其他所有节点认可呢？这里要说到两个关键，共识机制与价值载体。传统的中心化结构中，系统的共识有中心决定，参与方服从即可。去中心化的结构中，可就没这么简单，比特币区块链通过工作量证明来实现共识机制，大家一起竞争，满足条件即可记账，反之不满足条件的记录是不被大家认可的，这里的条件是大家都认可的结果（目前是采用通过哈希计算的值以多少个0开头，这里只是简单的提一下，肯定没说的这么简单），这样大家就达成了一致（可以看出区块链制造的是信任）。区块链的发展潜力体现在这个系统上所能承载的各种价值形式，说的有点迷糊，其实就是区块链不仅可以记账，对于任何可以用数字定义的资产都可以在区块链上记录，如今我们是信息时代，我们存在的证明大多都是数字了，那么我们就可以以数字形式进行价值存储或转移任何东西。</p><h2 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h2><p>智能合约的理念可以追溯到1994年，几乎与互联网同时出现。智能合约就像是一段逻辑代码，类似我们经常写的if…else，当发生什么情况而执行该情况下的代码，这个对我们来说很好理解，好歹是个程序员啊。我们现在会用合同来制定双方该各自遵守的条件，纸质合同也好，电子合同也好，都是需要人来去执行的，如某一方违约，那么按合同上的条款来执行。而智能合约就是把合同以代码的形式搬到区块链上，不需要任何人来监督执行，出现问题会触发条款自动执行，只要先预编好执行代码就行，这个交易智能化的以后一定会产生巨大影响。目前的比特币的脚本语言并不是图灵完备（图灵不完备的语言常常是因为循环或递归受限，无法实现特定的数据结构，可写的程序有限&lt;可以看看网上的介绍&gt;）的，所以在扩展性上比特币区块链所支持的资产定义和交易模式还比较有限，因此，业内有些人开始尝试开发支持图灵完备脚本语言的区块链，其中以太坊（Ethereum，可以自己去查一下，数字货币市值排名第二）就是个典型的例子。</p><h1 id="区块链技术原理"><a href="#区块链技术原理" class="headerlink" title="区块链技术原理"></a>区块链技术原理</h1><h2 id="区块链中的密码学"><a href="#区块链中的密码学" class="headerlink" title="区块链中的密码学"></a>区块链中的密码学</h2><p>在比特币区块链的整个体系中大量使用了公开的加密算法，比如Merkle Tree哈希树算法、椭圆曲线算法、SHA-256哈希算法、对称加密算法以及一些编码算法，如Base58编码、Verlnt编码、DER编码等。</p><p>这里说几个。比特币使用了基于secp256k1椭圆曲线数学的公钥密码学算法，它包含公钥和私钥，交易发出方用私钥进行签名，并将签名与原始数据发送给整个比特币网络，网络中所有节点则用公钥对交易有效性进行验证。签名算法保证了交易是由拥有对应私钥的人所发出的，核心就在于证明数据是签名者发出的、不可抵赖的，不是待签名数据本身的保密性。再说一个SHA-256哈希算法，SHA是安全散列算法（Secure Hash Algorithm）的缩写，是一个密码散列函数家族，由美国国家安全局（NSA）设计，美国国家标准与技术研究院（NIST）发布的，包括SHA-1、SHA-224、SHA-256、SHA-384和SHA-512五种变体，主要用于数字签名标准，其中SHA-256是输出值为256位的哈希算法。</p><h2 id="区块链组成"><a href="#区块链组成" class="headerlink" title="区块链组成"></a>区块链组成</h2><p>区块链数据由地址、交易、区块、网络组成。比特币用地址来表示标识一笔交易的支出方与接收方。交易最终需要被记录到有区块确认并完成的统一的账本上，每一个区块的产生都会被打上时间戳，最终生成的就是交易证明了。可以这么理解，所有的交易记录都是一条数据，也就是交易凭证，你所含有的资产其实也就是一条记录，只是大家都认可。每个独立节点之间又通过比特币网络来建立联系，这样就组成了一个去中心化的、分布式的电子交易记录时间戳服务器系统。</p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p>地址其实是公钥的另一种表现形式，可以理解为公钥的摘要。生生过程如下：</p><ul><li>1.生成椭圆曲线私钥与公钥。</li><li>2.将公钥通过SHA-256哈希算法处理，得到32字节的哈希值。</li><li>3.对于得到的哈希值，通过RIPEMD-160算法来得到20字节的哈希值——Hash160。</li><li>4.把由版本号￼+Hash160组成的21字节数据进行双次SHA-256哈希运算，得到的哈希值的前4字节作为校验和，放置在21字节数据的末尾。</li><li>5.对组成的25字节数组进行Base58编码，就可得到地址。</li></ul><h3 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h3><p>关于交易。中本聪的白皮书里，比特币被定义为一个链式的数字签名串。每一位电子货币的所有者通过这样的方式将它转移给下一位所有者：对前一个交易和下一位所有者的公钥签署一个数字签名，并将这个签名附加在交易的末尾。收款人通过验证签名，就可以验证电子货币的所有者链条。交易的本质是一个包含交易发送方、接收方、资产转移等相关信息的数据结构，其数据结构如下：</p><ul><li>版本（version），这笔交易参照的规则，4字节</li><li>输入数量（IN-counter），交易输入（TxIn）列表的数量，1～9字节</li><li>输入列表，一个或多个交易输入，大小不定</li><li>输出数量（Out-counter），交易输出（TxOut）列表的数量，1～9字节</li><li>输入列表，一个或多个交易输出，大小不定</li><li>锁定时间（Lock time），4字节</li></ul><h3 id="UTXO"><a href="#UTXO" class="headerlink" title="UTXO"></a>UTXO</h3><p>UTXO（Unspent Transaction Outputs）结构。UTXO是未花费的交易输出，这是比特币交易生成及验证的一个核心概念。比特币规定每一笔新交易的输入必须是某笔交易未花费的输出。至此，比特币的交易输入有3种：标准输入、花费挖矿奖励、产生挖矿奖励（上文说到，对于记账成功的节点会获得比特币奖励）。</p><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>脚本是交易里另一个比较重要的技术。每一笔交易的每一项输出，严格意义上讲并不是指向一个地址，而是指向一个脚本。脚本类似于一套规则，它约束着接收方怎样才能花掉这个输出上锁定的资产。目前常用的比特币脚本主要分为两种，一种是普通的P2PKH类型（Pay-to-Public-Key-Hash），即支付给公钥的哈希值是地址，接收方只需要使用地址对应的私钥对该输出进行签名，即可花掉该输出。另一种是P2SH（Pay-to-Script-Hash），支付脚本的哈希值。拿多重签名来举例，它要求该输出要有N把私钥中的M把私钥（M≤N）同时签名才能花掉该资产，它类似于现实生活中需要多把钥匙才能同时打开的保险柜，只是更加灵活。<br>比如在比特币中，P2PKH的脚本规则如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Pubkey script:OP_DUP OP_HASH160 &lt;PubkeyHash&gt; OP_CHECKSIG</div><div class="line">Signature script:&lt;sig&gt;&lt;pubkey&gt;</div></pre></td></tr></table></figure></p><p>P2SH脚本规则如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Pubkey script:OP_HASH160 &lt;Hash160 (redeemScript) &gt; OP_EQUAL</div><div class="line">Signature script:&lt;sig&gt;[sig][sig...] &lt;redeemScript&gt;</div></pre></td></tr></table></figure></p><p>这个脚本我也不懂，放出来给大家观赏，可以看出P2SH中多重签名的概念，脚本执行很类似于Java执行再JVM中，”VM”来解析指令。脚本的存在，近实现了区块链可编程。但是，比特币区块链的脚本机制相对简单，是非图灵完备的，目前以太坊实现了一个支持图灵完备脚本语言的区块链平台。</p><h3 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h3><p>区块结构如下（Merkle Tree基本特点请百度）：</p><ul><li>魔术码：固定值0xD9B4BEF9，4字节</li><li>区块大小：用字节表示该段之后的区块大小，1～9字节</li><li>区块头：包含6个字段，80字节（由4字节的版本、32字节的上一个区块的哈希值、32字节的Merkle Root Hash、4字节的时间戳、4字节的档期难度值、4字节的随机数组成）</li><li>交易数量：交易列表长度，1～9字节</li><li>交易列表：记录到区块的交易信息列表中，大小不定</li></ul><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>比特币网络的相关功能如下：</p><ul><li>1.新交易广播（使用洪水算法Flooding,是时候把大学的课本搬出来了）到全网的节点，每个节点会收到交易消息。</li><li>2.每个（挖矿）节点将新交易收集到节点的内存，并组装成区块。</li><li>3.每个（挖矿）节点都尝试在自己的区块中找到一个具有足够难度的工作量证明。</li><li>4.（挖矿）节点找到一个工作量证明，把有效的区块数据向全网进行广播。</li><li>5.当且仅当包含在该区块中的交易都是有效的，并验证其完成了工作量证明，其他节点才认同该区块的有效性。</li><li>6.其他（挖矿）节点表示接受该区块，并在该区块的末尾制造新的区块以延长整个区块的链条。</li></ul><h2 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h2><p>毕竟是个去中心化的系统，得保证整个P2P网络数据是一样的，还得保证对大家都是公平的，那就得有一套规约，也就是大家都遵守的协议，这里叫共识算法。两大核心：工作量证明与最长链机制。</p><h3 id="工作量证明"><a href="#工作量证明" class="headerlink" title="工作量证明"></a>工作量证明</h3><p>工作量证明（POW）可简单地理解为一份证明，用来确认你做过一定量的工作。说说比特币网了中的POW，如果想生成一个新的区块并写入区块链，则必须解出比特币网络出的工作量证明的迷题。这道题的3个关键要素是工作量证明函数、区块及难度值。其中难度值是用来调控的，就是在不管你有多大的挖矿能力，新区块的产生速率都保持在10分钟一个。计算公式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">新难度值=旧难度值*（过去2016个区块话费时长/20160分钟）</div></pre></td></tr></table></figure></p><p>另外POW需要有一个目标值，极计算公式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">目标值 = 最大目标值/难度值</div></pre></td></tr></table></figure></p><p>其中最大目标值为一个恒定值：0x00000000FFFFFFFFFFFF FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF，目标值的大小与难度值成反比，比特币工作量证明的达成条件就是矿工计算出来的<strong><em>区块哈希值必须小于目标值</em></strong>。</p><p>解题步骤大致如下：</p><ul><li>1.生成coinbase交易，并与其他所有准备打包进区块的交易组成交易列表，通过Merkle Tree算法生成Merkle Root Hash。</li><li>2.把Merkle Root Hash及其他相关字段组装成区块头，将区块头的80字节数据作为工作量证明的输入。</li><li>3.不停地变更区块头中的随机数（即nonce的数值），并对每次变更后的区块头做双重SHA-256运算（即SHA256 （SHA 256（Block_Header））），将结果值哈希反转并与当前网络的目标值对应的十进制字符串做对比，如果小于目标值，则解题成功，工作量证明完成。</li></ul><h3 id="最长链机制"><a href="#最长链机制" class="headerlink" title="最长链机制"></a>最长链机制</h3><p>比特币网络要求所有节点都遵循一个协议（共识），所有保存到本地的区块链必须是被本地节点验证通过的最长链。由于区块链的每个区块必须引用它的前一个区块，所以最长链是最难推翻的。</p><h3 id="算力攻击"><a href="#算力攻击" class="headerlink" title="算力攻击"></a>算力攻击</h3><p>当攻击者拥有的算力超过全网算力的51%时，可以用这些算力来重新计算已经确认过的区块，实现攻击，业内形象的称为51%算力攻击。中本聪在白皮书里做了个数学推算来证明比特币区块链体系的安全性，此计算证明比特币体系在设计上已经大大降低了双重支付（双花）的可能，另外对于51%算力攻击也被证明需要花费较高的攻击成本，而且也由于社区的理性选择，让攻击的成功率很低。（证明流程什么的就不赘述了，也说不好，请移步度娘谷哥）</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>至此，也介绍了比特币区块链的大部分概念，也就说个大概，对每个点说的并不是很全。还有像区块链的应用、侧链技术及其应用、货币、信用什么的就不说了，也说不好，这本书涉及的东西太多，也是刚了解可能思绪还比较乱能力也较差，肚子里有很多话想表达，可真的说也很难一一说全（可能找到了初恋的感觉），还是建议大家去读读这本书然后有自己的认识。现在就觉得，当遇到不懂的就去找本书看，也不用被各种的推送看的一头雾水，你只有去看看更完善的东西，才有自己的理解，一篇文章是看不出啥的。共勉。</p><h1 id="我从区块链中得到了什么"><a href="#我从区块链中得到了什么" class="headerlink" title="我从区块链中得到了什么"></a>我从区块链中得到了什么</h1><p>这部分就写下，我看这本书写下的想法吧。</p><blockquote><p>区块链是一个对人性悲观却非常真诚的协议。</p></blockquote><p>作为一个程序员，我不得不感叹区块链的技术，但我更喜欢的是区块链背后的哲学。区块链背后的思想是很伟大的，接受人性，善也好恶也罢，是对人性的悲观检测，考虑到你可能出现的所有情况，每个人活的都像自己，并不会因为你像自己而对他人造成损失。虽说是去中心化，但也有一套规约，像共识机制，与中心化不同的是我们的行为是对现有制度的屈服（不是来自于个人意志），区块链想做到的是你的决定都是来自你自己理性的判断，你是“自私”的，你会去考虑投入与损失，知道自己该做什么而使自己的利益最大化，是对自由的向往。</p><p>For freedom!!!</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>本文脑图地址：<a href="http://naotu.baidu.com/file/453a9b4bbfa8a7485e97188129cb04a2?token=8e15a160ba9e943e" target="_blank" rel="external">《区块链》</a></p><p>相关文章：<br><a href="http://www.woshipm.com/blockchain/887991.html" target="_blank" rel="external">区块链微信：对不起，你言而无信！</a><br><a href="http://www.woshipm.com/blockchain/870294.html" target="_blank" rel="external">区块链养猫，我们时代的一个不和谐的符号</a></p><p>书籍（电子版可在微信读书app搜索）：<br>《区块链：定义未来金融与经济新格局》（作者：火币网 张健）</p><hr><p>2018.01.27 00:36 -  完</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近大家可能被区块链的推送推的烦了，不只是“区块链”，还有这些名词：“炒币”、“挖矿”、“矿工”、“区块链”、“ICO”等。也许由于之前的勒索病毒的影响太大，使得它将用于其支付的比特币推向了白热化，各大媒体都去谈论比特币是什么，“区块链”技术渐渐从极客圈向大众圈扩散，加上比特币汇率的变化（截至写这篇博客BTC/CNY:86655.16），更让其走进了投资圈。我写这篇博客或许也是在蹭热点，但请往下看。&lt;/p&gt;
    
    </summary>
    
      <category term="书籍分享" scheme="http://JohnneyAnn.github.io/categories/%E4%B9%A6%E7%B1%8D%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="读书笔记" scheme="http://JohnneyAnn.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="区块链" scheme="http://JohnneyAnn.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>地铁</title>
    <link href="http://JohnneyAnn.github.io/2018/01/27/%E5%9C%B0%E9%93%81/"/>
    <id>http://JohnneyAnn.github.io/2018/01/27/地铁/</id>
    <published>2018-01-27T03:22:39.817Z</published>
    <updated>2018-01-27T03:22:39.817Z</updated>
    
    <content type="html"><![CDATA[<p>《地铁》</p><a id="more"></a><p>走在去地铁的路上<br>时间充裕<br>总有人时间是赶的<br>他们在奔跑着<br>加速的走着<br>不是怎的<br>我也跑了起来<br>可能<br>我怕 挡了别人的去路<br>也怕 别人挡了我的路 </p><p>地铁上<br>形形色色<br>发呆  沉思  阅读  小憩<br>交谈偏少<br>安静的无奈的等待<br>很慢<br>很快<br>可能与我一般<br>还有很长的路要走<br>我看到周遭的焦虑<br>长时间于地铁上<br>若心态不予调节<br>那定不如我这般惬意 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《地铁》&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://JohnneyAnn.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://JohnneyAnn.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="诗" scheme="http://JohnneyAnn.github.io/tags/%E8%AF%97/"/>
    
  </entry>
  
  <entry>
    <title>醒来</title>
    <link href="http://JohnneyAnn.github.io/2018/01/27/%E9%86%92%E6%9D%A5/"/>
    <id>http://JohnneyAnn.github.io/2018/01/27/醒来/</id>
    <published>2018-01-27T03:22:11.764Z</published>
    <updated>2018-01-27T03:22:11.764Z</updated>
    
    <content type="html"><![CDATA[<p>《醒来》<br><a id="more"></a></p><p>我在这醒来<br>看着周围漆黑一片<br>可能是深渊<br>或者是<br>我的境遇</p><p>我用尽力气<br>睁大眼睛<br>可光<br>藏掩的厉害<br>唤不起她</p><p>我感到绝望<br>但我不能停下</p><p>我试着行走<br>摸索<br>终于触碰到了温暖<br>是这片黑暗给予的温存<br>我尝试抱起它<br>无果</p><p>我想<br>我带不走它<br>带走的<br>是它给的信念</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《醒来》&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://JohnneyAnn.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://JohnneyAnn.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="诗" scheme="http://JohnneyAnn.github.io/tags/%E8%AF%97/"/>
    
  </entry>
  
  <entry>
    <title>2017书单</title>
    <link href="http://JohnneyAnn.github.io/2017/12/30/2017%E4%B9%A6%E5%8D%95/"/>
    <id>http://JohnneyAnn.github.io/2017/12/30/2017书单/</id>
    <published>2017-12-29T16:01:09.274Z</published>
    <updated>2017-12-29T16:01:09.270Z</updated>
    
    <content type="html"><![CDATA[<p>2017即将结束，总得做点什么，今天去看看电影版的《解忧杂货铺》（东野圭吾著），给东叔一份尊敬，也给自己一个总结，这是我看的第二本书。</p><a id="more"></a><h1 id="一个偶然"><a href="#一个偶然" class="headerlink" title="一个偶然"></a>一个偶然</h1><p>那时住油坊桥，周末常有小贩摆摊于地铁口，卖些盗版书或小商品。周六下班早，于是在此逗留片刻想淘本有趣的书装一下文化，无奈并不止其内容，也未曾看过&gt;书评，自然不知道哪本该是有趣的。现在想想一本陌生的书对于小白来书，有趣的名字，好看的封面该是他选择的理由，于是，我选择了《皮囊》（蔡崇达著），&gt;因为名字。</p><p>时常在想，我们用来思考的主体是大脑，那我是我的大脑么？我们会去说我想，但不会说大脑想，用我来证明是我在想。再者，我们可能会去说我的大脑在思考，&gt;这种说法该是认为大脑是我的一部分，进而认为大脑不是本我，但是当你在有这个想法的时候，正是大脑在操控着，现在说说到底是谁在想？好了，不在想了，在&gt;想脑袋会炸的，大脑说：其实是我不让你想，想明白咱们就脱离了。或许，就做个皮囊吧，成全大脑的阴谋。</p><p>以上是我看到皮囊两个字的意淫，也不是搞哲学的，就不难为自己。我“强迫”自己看完皮囊，倒不是这本书不好看，是我得改变我晕书的毛病，现在好似做到了。《皮囊》里有个句子很喜欢送给大家：</p><blockquote><p>能真实地抵达这个世界的，能确切地抵达梦想的，不是不顾一切投入想象的狂热，而是务实、谦卑的，甚至你自己都看不起的可怜和隐忍。</p></blockquote><p>看完解忧杂货店电影回来继续写这篇博客。大多数情况下，电影很难去还原原著，这是由于我们看书时根据书中的描述而想象出该有的情景，那么电影可以说是别人的理解放到荧幕展现给你，因此稍有与自己想象不同的情景都是难以接受的，后而去抨击电影摧毁了原著。当然，每个人都有自己对原著的理解这无可厚非，就今天的电影而言，对我来说虽有出处，但好在影片中主要的故事情节都有描述，有泪点也有笑点，觉得将这本书想要表达的内容都表达了，该有的都解释到了，这已经很不错了，我也不太喜欢去谈论演员的演技，情节在能够引起观众的共鸣，这些倒不是很重要。所以，还是推荐给大家，可以一看。</p><p>《解忧杂货铺》这是我看的第二本书，如果说《皮囊》是改变习惯，那这本是真的吸引到我了，让我有了更像看下去的信念，于是又读了东野圭吾的好几本书，后来觉得读书是颇有乐趣的一件事。到现在也看了不少，就把书单写下。</p><h1 id="2017书单"><a href="#2017书单" class="headerlink" title="2017书单"></a>2017书单</h1><h2 id="1-《皮囊》–蔡崇达"><a href="#1-《皮囊》–蔡崇达" class="headerlink" title="1.《皮囊》–蔡崇达"></a>1.《皮囊》–蔡崇达</h2><p>我的第一本书，被名字所吸引，一部有着小说阅读质感的散文集。</p><h2 id="2-《解忧杂货店》–东野圭吾"><a href="#2-《解忧杂货店》–东野圭吾" class="headerlink" title="2.《解忧杂货店》–东野圭吾"></a>2.《解忧杂货店》–东野圭吾</h2><p>前来咨询的人，每个人心中都有了答案，重要的是自己想积极认真的生活。</p><h2 id="3-《追风筝的人》–卡勒德•胡赛尼"><a href="#3-《追风筝的人》–卡勒德•胡赛尼" class="headerlink" title="3.《追风筝的人》–卡勒德•胡赛尼"></a>3.《追风筝的人》–卡勒德•胡赛尼</h2><p>“为你，千千万万遍”。</p><h2 id="4-《嫌疑人X的献身》-–东野圭吾"><a href="#4-《嫌疑人X的献身》-–东野圭吾" class="headerlink" title="4.《嫌疑人X的献身》 –东野圭吾"></a>4.《嫌疑人X的献身》 –东野圭吾</h2><p>推理小说，前有柯南后有东野圭吾，哈哈。</p><h2 id="5-《岛上书店》-–加布瑞埃拉泽文"><a href="#5-《岛上书店》-–加布瑞埃拉泽文" class="headerlink" title="5.《岛上书店》 –加布瑞埃拉泽文"></a>5.《岛上书店》 –加布瑞埃拉泽文</h2><p>我们读书而后知道自己并不孤独。</p><h2 id="6-《我们仨》-–杨绛"><a href="#6-《我们仨》-–杨绛" class="headerlink" title="6.《我们仨》 –杨绛"></a>6.《我们仨》 –杨绛</h2><p>爱是生活的点滴。生离固然痛苦，可死别才是不见啊。</p><h2 id="7-《无声告白》-–伍绮诗"><a href="#7-《无声告白》-–伍绮诗" class="headerlink" title="7.《无声告白》 –伍绮诗"></a>7.《无声告白》 –伍绮诗</h2><p>我们终此一生，就是摆脱他人的期待，找到真正的自己。</p><h2 id="8-《乖，摸摸头》-–大冰"><a href="#8-《乖，摸摸头》-–大冰" class="headerlink" title="8.《乖，摸摸头》 –大冰"></a>8.《乖，摸摸头》 –大冰</h2><p>发生在大冰身边的真实故事，我们喜欢看故事，然后想到自己。</p><h2 id="9-《阿弥陀佛么么哒》-–大冰"><a href="#9-《阿弥陀佛么么哒》-–大冰" class="headerlink" title="9.《阿弥陀佛么么哒》 –大冰"></a>9.《阿弥陀佛么么哒》 –大冰</h2><p>同上，看完之后及其向往自由。。。</p><h2 id="10-《白夜行》-–东野圭吾"><a href="#10-《白夜行》-–东野圭吾" class="headerlink" title="10.《白夜行》 –东野圭吾"></a>10.《白夜行》 –东野圭吾</h2><p>推理。不必提醒你还只是个孩子。</p><h2 id="11-《人人都是产品经理》-–苏杰"><a href="#11-《人人都是产品经理》-–苏杰" class="headerlink" title="11.《人人都是产品经理》 –苏杰"></a>11.《人人都是产品经理》 –苏杰</h2><p>算是影响很大的书，对于没有学习软件工程的我，帮助我去理解公司的一些东西，告诉我该怎么做。博客名就是模仿苏杰的。。。</p><h2 id="12-《这么慢，那么美》-–罗敷"><a href="#12-《这么慢，那么美》-–罗敷" class="headerlink" title="12.《这么慢，那么美》 –罗敷"></a>12.《这么慢，那么美》 –罗敷</h2><p>一本介绍北欧的书，一定要去一次！</p><h2 id="13-《逻辑思维：迷茫时代的明白人》-–罗振宇"><a href="#13-《逻辑思维：迷茫时代的明白人》-–罗振宇" class="headerlink" title="13.《逻辑思维：迷茫时代的明白人》 –罗振宇"></a>13.《逻辑思维：迷茫时代的明白人》 –罗振宇</h2><p>上次说的卖焦虑的那个家伙，哈哈，但确实有很多观点，有经济也有历史，还算有趣。</p><h2 id="14-《逻辑思维：中国为什么有前途》–罗振宇"><a href="#14-《逻辑思维：中国为什么有前途》–罗振宇" class="headerlink" title="14.《逻辑思维：中国为什么有前途》–罗振宇"></a>14.《逻辑思维：中国为什么有前途》–罗振宇</h2><p>分析历史，证明未来。</p><h2 id="15-《一本书看懂经济学》-–庆裕"><a href="#15-《一本书看懂经济学》-–庆裕" class="headerlink" title="15.《一本书看懂经济学》 –庆裕"></a>15.《一本书看懂经济学》 –庆裕</h2><p>科普类读物。有很多与生活贴切的例子，与社会心理学有交叉，就觉得这些都一样。博弈论、囚徒困境不就是心理战么- -，还有《三体》中的猜疑链，社会学也一样。</p><h2 id="16-《人生十讲》-–季羡林"><a href="#16-《人生十讲》-–季羡林" class="headerlink" title="16.《人生十讲》 –季羡林"></a>16.《人生十讲》 –季羡林</h2><p>人吃饭时为了活着，但活着绝不是为了吃饭。</p><h2 id="17-《飞鸟集》-–泰戈尔"><a href="#17-《飞鸟集》-–泰戈尔" class="headerlink" title="17.《飞鸟集》 –泰戈尔"></a>17.《飞鸟集》 –泰戈尔</h2><p>诗集类，花花草草木木，清新风，双语读的，道行太浅，体会不深。</p><h2 id="18-《神探伽利略》-–东野圭吾"><a href="#18-《神探伽利略》-–东野圭吾" class="headerlink" title="18.《神探伽利略》 –东野圭吾"></a>18.《神探伽利略》 –东野圭吾</h2><p>5个推理小故事，东叔比较爱物理。</p><h2 id="19-《当我们在谈论爱情时我们在谈论什么》-–雷蒙德•卡佛"><a href="#19-《当我们在谈论爱情时我们在谈论什么》-–雷蒙德•卡佛" class="headerlink" title="19.《当我们在谈论爱情时我们在谈论什么》 –雷蒙德•卡佛"></a>19.《当我们在谈论爱情时我们在谈论什么》 –雷蒙德•卡佛</h2><p>描述的并不是优美的爱情故事，而是将不好的全部展示出来，结局留白的写作手法吸引了很多人的喜爱。最重要的观点，你并不知道自己在谈论什么。</p><h2 id="20-《活出生命的意义》-–维克多•弗兰克尔"><a href="#20-《活出生命的意义》-–维克多•弗兰克尔" class="headerlink" title="20.《活出生命的意义》 –维克多•弗兰克尔"></a>20.《活出生命的意义》 –维克多•弗兰克尔</h2><p>心理学书籍，作者从集中营出来后写的，被压迫的过去需要调节，提出的“意义疗法”很适用。</p><h2 id="21-《愿你迷路到我身旁》-–蕊希"><a href="#21-《愿你迷路到我身旁》-–蕊希" class="headerlink" title="21.《愿你迷路到我身旁》 –蕊希"></a>21.《愿你迷路到我身旁》 –蕊希</h2><p>微信读书送的，情情爱爱什么的，也硬着头皮看完了，大家还是别看了。</p><h2 id="22-《我这一生都比别人跑得慢》-–东土大唐"><a href="#22-《我这一生都比别人跑得慢》-–东土大唐" class="headerlink" title="22.《我这一生都比别人跑得慢》 –东土大唐"></a>22.《我这一生都比别人跑得慢》 –东土大唐</h2><p>左手编程，右手文学。榜样啊，84篇，来自于生活，很有趣。</p><h2 id="23-《周鸿祎自述：我的互联网方法论》-–周鸿祎"><a href="#23-《周鸿祎自述：我的互联网方法论》-–周鸿祎" class="headerlink" title="23.《周鸿祎自述：我的互联网方法论》 –周鸿祎"></a>23.《周鸿祎自述：我的互联网方法论》 –周鸿祎</h2><p>科技大佬都在出书，周老板这本该叫我的360成功之路，当然某些观点还是适用的。</p><h2 id="24-《湖畔》-–东野圭吾"><a href="#24-《湖畔》-–东野圭吾" class="headerlink" title="24.《湖畔》 –东野圭吾"></a>24.《湖畔》 –东野圭吾</h2><p>推理之下是对现实的拷问，父母为了孩子逾越道德的界线。</p><h2 id="25-《哥伦比亚的倒影》-–木心"><a href="#25-《哥伦比亚的倒影》-–木心" class="headerlink" title="25.《哥伦比亚的倒影》 –木心"></a>25.《哥伦比亚的倒影》 –木心</h2><p>读木心深知自己不足，语言简约意味深长。</p><h2 id="26-《道德经》-–老子"><a href="#26-《道德经》-–老子" class="headerlink" title="26.《道德经》 –老子"></a>26.《道德经》 –老子</h2><p>第三遍，也手抄了一些，真的是博大精深，得慢慢体会。道无为而无所不为。</p><h2 id="27-《马云：未来以来》-–阿里巴巴集团"><a href="#27-《马云：未来以来》-–阿里巴巴集团" class="headerlink" title="27.《马云：未来以来》 –阿里巴巴集团"></a>27.《马云：未来以来》 –阿里巴巴集团</h2><p>是马爸爸的演讲，主要就是几个观点，企业要考虑为社会做什么，企业要考虑未来的事等等。</p><h2 id="28-《从0到1-开启商业与未来的秘密》-–蒂尔•马斯特斯"><a href="#28-《从0到1-开启商业与未来的秘密》-–蒂尔•马斯特斯" class="headerlink" title="28.《从0到1:开启商业与未来的秘密》 –蒂尔•马斯特斯"></a>28.《从0到1:开启商业与未来的秘密》 –蒂尔•马斯特斯</h2><p>科技大佬热议之书来自paypel黑帮之首。阐述了自己的创业历程与心得，找到自己的利基市场。</p><h2 id="29-《三体》（全集）-–刘慈欣"><a href="#29-《三体》（全集）-–刘慈欣" class="headerlink" title="29.《三体》（全集） –刘慈欣"></a>29.《三体》（全集） –刘慈欣</h2><p>包含地球往事、黑暗森林和死神永生三册。推荐了很多次，提出宇宙社会学的概念，将一切放到宇宙的尺度去衡量，阐述文明的历程，实为震撼。</p><h2 id="30-《咖啡原来是这样的啊》-–童铃"><a href="#30-《咖啡原来是这样的啊》-–童铃" class="headerlink" title="30.《咖啡原来是这样的啊》 –童铃"></a>30.《咖啡原来是这样的啊》 –童铃</h2><p>咖啡科普，介绍不同地区的咖啡与文化，有些许装X的韵味，但学习并不是一件坏事，丰富自己的知识体系。</p><h2 id="31-《社会心理学》-–Elliot-Aronson"><a href="#31-《社会心理学》-–Elliot-Aronson" class="headerlink" title="31.《社会心理学》 –Elliot Aronson"></a>31.《社会心理学》 –Elliot Aronson</h2><p>解释社会行为，当我们对我们所处的社会有更理性的认识。</p><h2 id="32-《浮生六记》-–沈复"><a href="#32-《浮生六记》-–沈复" class="headerlink" title="32.《浮生六记》 –沈复"></a>32.《浮生六记》 –沈复</h2><p>自传散文体小说，写给芸的绝美情书，目前仅剩四记，描述了闲情逸致、悲欢离合、人情事态等等，读者能够感受作者的情绪，久久不能平静。</p><p>……还有些没看完的，遗漏的就不一一列举了，能记得的都是觉得不错的</p><p><strong>以下是听书，听书大多听个大概，不太占时间，这里举一些有趣的：</strong></p><h2 id="33-《宇宙的结构》"><a href="#33-《宇宙的结构》" class="headerlink" title="33.《宇宙的结构》"></a>33.《宇宙的结构》</h2><p>听书。我们希望能够有效的解释我们所处的世界，基础物理学解释不了的有量子力学，在解释不了的有弦理论。</p><h2 id="34-《万物起源》"><a href="#34-《万物起源》" class="headerlink" title="34.《万物起源》"></a>34.《万物起源》</h2><p>听书。宇宙来自虚无、生命源于偶遇、文明离不开想象力，意外结论的背后是科学的支撑。</p><h2 id="35-《文明的冲突与世界秩序的重建》"><a href="#35-《文明的冲突与世界秩序的重建》" class="headerlink" title="35.《文明的冲突与世界秩序的重建》"></a>35.《文明的冲突与世界秩序的重建》</h2><p>听书。用“文明”的角度解读世界格局与未来。</p><h2 id="36-《米开朗基罗传》"><a href="#36-《米开朗基罗传》" class="headerlink" title="36.《米开朗基罗传》"></a>36.《米开朗基罗传》</h2><p>艺术家不是拥有天赋就可以练成，还需要付出艰苦的努力甚至生命。</p><h2 id="37-《梵高传》"><a href="#37-《梵高传》" class="headerlink" title="37.《梵高传》"></a>37.《梵高传》</h2><p>用生命描绘自己的艺术和心灵。</p><h2 id="38-《拜占庭帝国》"><a href="#38-《拜占庭帝国》" class="headerlink" title="38.《拜占庭帝国》"></a>38.《拜占庭帝国》</h2><p>拜占庭孕育了欧洲文艺复兴的伟大文明，但最终还是走向了灭亡。</p><h2 id="39-《罗马帝国衰亡史》"><a href="#39-《罗马帝国衰亡史》" class="headerlink" title="39.《罗马帝国衰亡史》"></a>39.《罗马帝国衰亡史》</h2><p>一步步阐述罗马帝国如何走向衰落，具体可看之前的博客。</p><h2 id="40-《乌合之众》"><a href="#40-《乌合之众》" class="headerlink" title="40.《乌合之众》"></a>40.《乌合之众》</h2><p>大众心理学研究，之前有提过。</p><h2 id="41-《怪诞行为学》"><a href="#41-《怪诞行为学》" class="headerlink" title="41.《怪诞行为学》"></a>41.《怪诞行为学》</h2><p>这对学习心理学、行为经济学、研究用户都很有帮助。</p><h2 id="42-《活法》"><a href="#42-《活法》" class="headerlink" title="42.《活法》"></a>42.《活法》</h2><p>稻盛和夫独特的人生哲学，最令人印象深刻的三个观点：一、从简单的原则出发考虑问题；二、设定超出现有能力的高目标；三、努力到连老天爷都出手相助（工作现场有神明）。</p><h2 id="43-《干法》"><a href="#43-《干法》" class="headerlink" title="43.《干法》"></a>43.《干法》</h2><p>稻盛和夫：工作是一种修行，是洗涤灵魂的过程。</p><p>……</p><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>想看的东西太多，苦于时间不够，恨不得能一口吃了。</p><p>读书就像吃饭，吃完了虽然排了出去，但是正在帮助你成长。只有不断的去学习，丰富自己的知识体系，才能存活于未来。</p><p>最近可能是到了年终，就想写点东西啊。</p><hr><p>2017.12.29 23.53 完</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017即将结束，总得做点什么，今天去看看电影版的《解忧杂货铺》（东野圭吾著），给东叔一份尊敬，也给自己一个总结，这是我看的第二本书。&lt;/p&gt;
    
    </summary>
    
      <category term="书籍分享" scheme="http://JohnneyAnn.github.io/categories/%E4%B9%A6%E7%B1%8D%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="读书笔记" scheme="http://JohnneyAnn.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="记录" scheme="http://JohnneyAnn.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>尼尔森十大可用性原则</title>
    <link href="http://JohnneyAnn.github.io/2017/12/28/%E5%B0%BC%E5%B0%94%E6%A3%AE%E5%8D%81%E5%A4%A7%E5%8F%AF%E7%94%A8%E6%80%A7%E5%8E%9F%E5%88%99/"/>
    <id>http://JohnneyAnn.github.io/2017/12/28/尼尔森十大可用性原则/</id>
    <published>2017-12-28T15:52:19.731Z</published>
    <updated>2017-12-28T15:52:19.731Z</updated>
    
    <content type="html"><![CDATA[<p>尼尔森的十大可用性原则是于1995年1月1日发表，来自交互设计的一位web易用性大师——Jakob Nielsen人机交互学博士（Technical University of Denmark in Copenhagen）。<br><a id="more"></a></p><h1 id="一、Visibility-of-system-status-系统可见性原则（状态可见）"><a href="#一、Visibility-of-system-status-系统可见性原则（状态可见）" class="headerlink" title="一、Visibility of system status 系统可见性原则（状态可见）"></a>一、Visibility of system status 系统可见性原则（状态可见）</h1><p>系统应该让用户知道发生了什么，在适当的时间内做出适当的反馈。用户在网页上的任何操作，不论是单击、滚动还是按下键盘，页面应即时给出反馈。“即时”是指，页面响应时间小于用户能忍受的等待时间。</p><p>IDEA：我们在表单中对用户填写的信息进行实时校验；提供数据加载提示、数据加载进度；点击按钮按钮状态改变等等</p><h1 id="二、Match-between-system-and-the-real-world-匹配系统与真实世界（环境贴切）"><a href="#二、Match-between-system-and-the-real-world-匹配系统与真实世界（环境贴切）" class="headerlink" title="二、Match between system and the real world 匹配系统与真实世界（环境贴切）"></a>二、Match between system and the real world 匹配系统与真实世界（环境贴切）</h1><p>系统应该用用户的语言，用词，短语和用户熟悉的概念，而不是系统术语。遵循现实世界的惯例，让信息符合自然思考逻辑。大多数流通的翻译是针对网页的：网页的一切表现和表述，应该尽可能贴近用户所在的环境（年龄、学历、文化、时代背景），而不要使用第二世界的语言。</p><p>IDEA：对于按钮图标我们使用用户一眼就能看出其作用的图标，也就是尽可能的模拟真实世界，对用户反馈的信息使用用户熟悉的表述和名字，如错误提醒等。早前看深泽值人的提出的“无意识设计”，这对可供性设计有很好的阐述。可供性是物体或环境与生物体之间的一种关系，通过刺激的收集，提供给生物体表现出动作的机会。作为一种关系，可供性是动作的可能性，既不是环境也不是生物体单独的性质。当人们与环境发生无意识关联时，是处于最自然的状态的，这会降低用户的学习成本，如看到“垃圾桶”图标自然就知道这是删除类操作等。另外的就是根据用户群体，产生与用户的共鸣，多些情感化的东西，使其更贴近用户的生活，人机关系总是感性大于理性。</p><h1 id="三、User-control-and-freedom用户的控制性和自由度（撤销重作原则）"><a href="#三、User-control-and-freedom用户的控制性和自由度（撤销重作原则）" class="headerlink" title="三、User control and freedom用户的控制性和自由度（撤销重作原则）"></a>三、User control and freedom用户的控制性和自由度（撤销重作原则）</h1><p>用户经常错误地选择系统功能而且需要明确标识离开这个的“出口”，而不需要通过一个扩展的对话框。要支持撤销和重做的功能。大多数流通的翻译是针对网页的：为了避免用户的误用和误击，网页应提供撤销和重做功能。</p><p>IDEA：之前写的笔记系统，添加了回收站功能，用户可去回收站去复原删除的数据，当时的设计思路是对表结构的更改，增加一个标识列区分正常、删除、永久删除三个状态，这确实也是一种方法。后来发现并不是所有系统都具有回收站功能，或者基于已有表结构是难以走这条路的，并且真实的删除操作需要用户去自己去操作才可以，这就不合适了。看过一些不错的网站他们会在用户删除时会有一个小的悬浮框，用户可在短时间内选择撤销，为选择则在框消失后真实删除，我没有去查证他们怎么去实现的，自己想了一个法子。对于网页来说，我们可以去在用户删除的时候做一个悬浮框在其消失时去删除这并不难，但考虑用户如果在提示框消失之前点击了刷新或其他操作导致页面中心加载，那在前端的这个操作可能就失效了，或许可以去监听页面刷新的操作，在操作之前提前执行真实删除就能够达到目的。对于可以修改表结构，用户也希望不用自己收到去清空，我们可以添加标识列，在后台执行定时操作，删除在某一时间范围内的数据，这些只是目前的想法不保证正确性，回头去写个DEMO来测试。</p><h1 id="四、Consistency-and-standards一致性和标准化（一致性原则）"><a href="#四、Consistency-and-standards一致性和标准化（一致性原则）" class="headerlink" title="四、Consistency and standards一致性和标准化（一致性原则）"></a>四、Consistency and standards一致性和标准化（一致性原则）</h1><p>用户不必怀疑是否不同的语言，不同的情景，或者不同的操作产生的结果实际上是同一件事情。遵循平台的惯例。也就是，同一用语、功能、操作保持一致。</p><p>IDEA：这个是极其常见的了，节目风格的一致性，引导用户操作的一致性。</p><h1 id="五、Error-prevention-防错原则"><a href="#五、Error-prevention-防错原则" class="headerlink" title="五、Error prevention 防错原则"></a>五、Error prevention 防错原则</h1><p>比出现错误信息提示更好的是更用心的设计防止这类问题发生。在用户选择动作发生之前，就要防止用户容易混淆或者错误的选择。对于网页来说：通过网页的设计、重组或特别安排，防止用户出错。</p><p>IDEA：经常会说把用户当小白，将用户可能犯的错都考虑到，通过我们的设计使其避免，比如，删除时给出确认提示框，提示框按钮位置的编排，按钮样式的突出，多重防止误操作。</p><h1 id="六、Recognition-rather-than-recall-识别比记忆好（易取原则）"><a href="#六、Recognition-rather-than-recall-识别比记忆好（易取原则）" class="headerlink" title="六、Recognition rather than recall 识别比记忆好（易取原则）"></a>六、Recognition rather than recall 识别比记忆好（易取原则）</h1><p>尽量减少用户对操作目标的记忆负荷，动作和选项都应该是可见的。用户不必记住一个页面到另一个页面的信息。系统的使用说明应该是可见的或者是容易获取的。尽可能减少用户回忆负担，把需要记忆的内容摆上台面。</p><p>IDEA：还是说删除提示，删除提示应当给出必要的提示信息，告诉用户他刚刚做了什么操作，现在需要他确认什么，用户不必去回想刚刚点了啥操作。</p><h1 id="七、Flexibility-and-efficiency-of-use使用的灵活高效（灵活高效原则）"><a href="#七、Flexibility-and-efficiency-of-use使用的灵活高效（灵活高效原则）" class="headerlink" title="七、Flexibility and efficiency of use使用的灵活高效（灵活高效原则）"></a>七、Flexibility and efficiency of use使用的灵活高效（灵活高效原则）</h1><p>中级用户的数量远高于初级和高级用户数。为大多数用户设计，不要低估，也不可轻视，保持灵活高效。</p><p>IDEA：对于一些博客网站，提供Markdown编辑器，一般用户只需记住语法就可以写作，我觉得这是属于中级用户的，但也提供XHTML语言以及富文本编辑器，这样就满足了不同层次用户的需求，为大多数用户设计，兼容少部分特殊用户，如果只有Markdown，那用户会流失很多。</p><h1 id="八、Aesthetic-and-minimalist-design-审美和简约的设计（易扫原则）"><a href="#八、Aesthetic-and-minimalist-design-审美和简约的设计（易扫原则）" class="headerlink" title="八、Aesthetic and minimalist design 审美和简约的设计（易扫原则）"></a>八、Aesthetic and minimalist design 审美和简约的设计（易扫原则）</h1><p>对话中不应该包含无关紧要的信息。在段落中每增加一个单位的重要信息，就意味着要减少相应的弱化一些其他信息。互联网用户浏览网页的动作不是读，不是看，而是扫。易扫，意味着突出重点，弱化和剔除无关信息。</p><p>IDEA：看过一个广告行业的研究：人类的平均注意力时长从2000年的12秒下将到现在为8妙。这是个快节奏的时代，适应这些变化自然要做些改变，突出有用的内容，用户可快速捕获到重点信息，另外对于用户不关心的，我们能够帮用户完成的就不劳烦他大驾了，给个间断的提示就行。</p><h1 id="九、Help-users-recognize-diagnose-and-recover-from-errors-帮助用户识别，诊断，并从错误中恢复（容错原则）"><a href="#九、Help-users-recognize-diagnose-and-recover-from-errors-帮助用户识别，诊断，并从错误中恢复（容错原则）" class="headerlink" title="九、Help users recognize, diagnose, and recover from errors 帮助用户识别，诊断，并从错误中恢复（容错原则）"></a>九、Help users recognize, diagnose, and recover from errors 帮助用户识别，诊断，并从错误中恢复（容错原则）</h1><p>错误信息应该用语言表达（不要用代码），较准确地反应问题所在，并且提出一个建设性的解决方案。大多数流通的翻译是针对网页的：帮助用户从错误中恢复，将损失降到最低。如果无法自动挽回，则提供详尽的说明文字和指导方向，而非代码，比如404。</p><p>IDEA：当页面发生错误时，不提供报错信息，采用友好的故障界面，并提供用户能够明白的说明，告诉用户现在可以做什么，如回到首页，返回上一步等。我们的系统对404页面确实做了调整。</p><h1 id="十、Help-and-documentation-帮助文档（人性化帮助原则）"><a href="#十、Help-and-documentation-帮助文档（人性化帮助原则）" class="headerlink" title="十、Help and documentation  帮助文档（人性化帮助原则）"></a>十、Help and documentation  帮助文档（人性化帮助原则）</h1><p>如果系统不使用文档是最好的，但是有必要提供帮助和文档。任何信息应容易去搜索，专注于用户的任务，列出具体的步骤来进行。帮助性提示最好的方式是：1、无需提示；2、一次性提示；3、常驻提示；4；帮助文档。</p><p>IDEA：上文说到一个好的系统应当是无意识设计，是具备可供性的，但有时确实有必要提供一些提示帮助用户去理解。我们的系统中有一个工具模块，目前还是一个页面里面的嵌入功能，这个模块用户的学习成本较高，想达到想要的效果确实有难度，用户在使用时定会不知所措，未来缓解这部分的尴尬，目前采取常驻提示作为临时处理方案，用户可查看当前工具可以做什么，可以去进行哪些操作、如何操作。对于系统层面，部门对未使用过我们系统的人提供帮助文档。其他方面如表单填写是使用placeholder或其他的提示信息对用户容易产生困惑的敏感信息进行提醒。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>牢记这些可用性原则，在实现功能是在尽可能的情况下去遵循这些原则，任务时间充裕的情况下根据系统实际情况调整并执行，对旧模块进行微调。同样，在代码层面规范代码，参考阿里巴巴规约，优化逻辑，提高响应。</p><p><hr></p><p>2017.12.28 23:46完</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;尼尔森的十大可用性原则是于1995年1月1日发表，来自交互设计的一位web易用性大师——Jakob Nielsen人机交互学博士（Technical University of Denmark in Copenhagen）。&lt;br&gt;
    
    </summary>
    
      <category term="产品" scheme="http://JohnneyAnn.github.io/categories/%E4%BA%A7%E5%93%81/"/>
    
    
      <category term="设计" scheme="http://JohnneyAnn.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="学习" scheme="http://JohnneyAnn.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>公司这个团体</title>
    <link href="http://JohnneyAnn.github.io/2017/12/26/%E5%85%AC%E5%8F%B8%E8%BF%99%E4%B8%AA%E5%9B%A2%E4%BD%93/"/>
    <id>http://JohnneyAnn.github.io/2017/12/26/公司这个团体/</id>
    <published>2017-12-25T16:00:02.808Z</published>
    <updated>2017-12-25T16:00:02.808Z</updated>
    
    <content type="html"><![CDATA[<p>企业招人与用人方面该是怎么样的？作为公司团体中的一员确实很想了解清楚。这个高度有点高了，我们常说我们部门的人是服务员，服务于公司其他各个部门，那么，我算的上是一个底层服务员。作为底层服务员去大谈公司团体的科学方法论可能确实有点滑稽，但也是想记下现在的想法、推论，在以后学习更多的东西来回首去证明之，抑或是推翻之。<br><a id="more"></a></p><h1 id="招人的门槛"><a href="#招人的门槛" class="headerlink" title="招人的门槛"></a>招人的门槛</h1><p>大多数公司招人喜欢985、211等名校毕业的，这有它的道理。对于公司来说，应届生没有经验，实践能力也不能很快就看出来，那么你来自一个好学校就是对你之前20多年的一份满意的答卷，至少从这可以看出你算是优秀的，这对以后的你来说也是一个很好的根基。学校分三六九等，不同学校的教学质量，学生素质自然有所差别。这句话颇很正确，也有以偏概全之意，学生作为学校群体中的一员，易被去个体化而迷失在人群中，但个体的人格特征也有不可被同化的一部分，这也是值得欣赏的一部分。</p><p>公司的可持续发展离不开人才的引进与培养。来自差学校的是否属于人才？来自好学校的是否属于人才？这些都不敢说，总有些独特的人做着独特的事，因为群体效应形成刻板印象而一棍子打死，这并不智慧。被招进来的人在公司留下的时间由什么来决定？我们从社会心理学中团体认同感及认知失调这两个方面可以去分析。</p><p>在公司停留的时间取决于进入公司的难易程度以及后期公司文化是否给予个体团体认同。大多数情况下，来自于名牌大学学生比来自于其他学校的学生更容易进入一家公司（方法论中的变量只是来自不同的学校，假定在个人能力、公司的规模等其他因素保持一致，否则可能不成立），这种情况出现的比较多，也借此来说明这个问题。有人在的地方就会有抱怨，人们似乎总是认为生活让其饱受摧残。在公司也一样，总有人抱怨公司的种种不满，有不满而离去的，也有不满而继续待下的，前者多为容易进入公司的那批人，后者则是较难的那批。容易进入公司的，对自我有着特别的认同感，也相对自信，认为下一份也该是轻易获得，而对于现在的公司的不满易被放大；较难进入公司的，也会遇到对公司的不满，此类对于公司的不满习惯放小，大多在接受范围之内。工作对于个体来说是得到的东西，不管好与不好，若是你艰难得到的自然会加倍珍惜，是人性也是害怕认知失调。人们也习惯用让自己更容易接受的解释来缓解自己的认知失调，你那么拼命的拿到，如今又不喜欢，对于我们是很难接受的，我们回去寻找有利的信息为我们的决定做支撑，“可能在这一块公司有着不当的地方，但其他地方还不错啊”，这样的想法促使人们去接受而让自身变的轻松。</p><p>对于愿意留下的部分，若留下更长的时间是由于公司文化、价值观与其自身价值观得以契合，自身价值在整个团体中得以体现而留存。面试中，多会考虑被面试者是否认同公司的文化，因此会去问被面试者的价值观，这可能也是出于这方面的考虑，另外，对于已有工作经验的人，会去考虑其离职原因、曾在职时长，可见对于未来员工留存于公司的时间公司是比较在意的。但就校招而言，对于进入公司的难易程度似乎考虑欠缺。</p><p>马云爸爸说清华大学的应该以欣赏的阳光去看待杭州师范大学的学生，杭师大的学生也应当以欣赏的眼光看待自身。对此，我更愿意看成这两所大学是前文提到的两种大学的代表，因此我深信不疑。再来说公司招人，应当给予第二类学校一定的机会，不管对于两类大学的任何一类，其进入公司的难易程度应当保持一致，在几轮面试中进行筛选，不丢失好学校的差生，也不丢失差学校的优生，也能更加明确的pass掉不需要的员工，从而使得来自好学校的学生对公司的认同，来自差学校的学生对公司更加用户，方能就留，为公司创造更多的利益。运用好心理战或许对这些很有帮助。</p><h1 id="团体效应"><a href="#团体效应" class="headerlink" title="团体效应"></a>团体效应</h1><p>团体或群体是社会学、社会心理学一个重要的研究方向，个体组成团体，一个个小团体组成现在我们见到的社会，社会上几乎所有的活动都是团体活动，《乌合之众》这本书对大众心理学有很好的描述，可以帮助我们了解很多社会活动，从某种程度上说，“人以群分”不算是一个完全的贬义词，描述的正是事实。</p><p>团体在公司也很有体现，据社会心理学的解释，团体是两个或两个以上彼此互动、彼此依赖的人，他们的学校和目标使得他们相互影响。那么，公司毫无疑问是团体，我们是为了共同目的而聚集在一起的人。既然是团体，有哪些可以用的上的心理学知识？</p><p>他人在场。他人在场时是否会影响你的行为？他人在场一般分为两种情况，一是其他人跟自己做同一件事，二是其他人只是观察你做事而自己并不做。他人在场是否会促进我们的工作效率呢，这想必很多人都会关心。会，也不会。这得分两种情况：简单任务与复杂任务。想象一下，让你做一件简单的事，对你而言做这件事就像是第二本能，熟悉的不能再熟悉，相必你能够快而好的完成这件事，有效率也有质量（你急与想表现自己），倘若这件事较为复杂或者是让你学习新知识，你该开始担心的，你担心领导会不会给你较坏的评价，这会让你在这项任务上表现更差。人们总是对其他人如何评价自己非常关系。</p><p>对于管理者来说，当要求你的员工完成一些相当简单的任务时，给他增加点评价焦虑不是一件坏事，这能够提供工作效率，但如果其个人努力得不到评估，就不能让其和别人做同一件事，这会引起他的懈怠；对于复杂任务，你则需要降低其评价焦虑，可将其编排在团体内，个人的表现不会得到评价，这里也叫责任分担，效绩可能会更好。</p><p>人们乐于去表现自己，而不愿意得到坏的评价。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>如果公司的价值观、现状、人事都与预期的差不太多，并没有与自身的愿景背道而驰，就该去学习，也愿意待的时间更长一点，现在需要的还是积累，现在常谈的是佛系90后，这种调侃也是人们想借助此来消除当前所处的焦虑，担心的并非是脱发、恐老，而是是否能如佛学思想般静心，若能静心，自然没什么好担心。</p><p>圣诞快乐。</p><p><hr></p><p>2017.12.25 23:55完</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;企业招人与用人方面该是怎么样的？作为公司团体中的一员确实很想了解清楚。这个高度有点高了，我们常说我们部门的人是服务员，服务于公司其他各个部门，那么，我算的上是一个底层服务员。作为底层服务员去大谈公司团体的科学方法论可能确实有点滑稽，但也是想记下现在的想法、推论，在以后学习更多的东西来回首去证明之，抑或是推翻之。&lt;br&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://JohnneyAnn.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="愚见" scheme="http://JohnneyAnn.github.io/tags/%E6%84%9A%E8%A7%81/"/>
    
      <category term="心理学" scheme="http://JohnneyAnn.github.io/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
      <category term="工作" scheme="http://JohnneyAnn.github.io/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>MySQL存储过程</title>
    <link href="http://JohnneyAnn.github.io/2017/12/23/MySQL%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://JohnneyAnn.github.io/2017/12/23/MySQL存储过程/</id>
    <published>2017-12-23T01:30:36.133Z</published>
    <updated>2017-12-23T01:30:36.133Z</updated>
    
    <content type="html"><![CDATA[<p>有这样一个需求，从A表中查询出结果，作为B表插入的查询条件，之后循环查询并插入。从网上看了些解决方案，这里写了一个存储过程的DEMO。<br><a id="more"></a><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> SELECT_4_INSERT;<span class="comment">-- 若存在此存储过程先删除</span></div><div class="line"></div><div class="line">DELIMITER $$ <span class="comment">-- 定义结束符 避免与存储过程中“;”冲突 语句到"$$"才算结束</span></div><div class="line"></div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> SELECT_4_INSERT() <span class="comment">-- 创建存储过程</span></div><div class="line"><span class="keyword">BEGIN</span></div><div class="line"><span class="comment">-- 定义结束标识 用于判断是否结束循环 也可以用FALSE，MYSQL认为非0为TRUE</span></div><div class="line"><span class="keyword">DECLARE</span> DONE <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;  </div><div class="line"><span class="comment">-- 用于存储结果集的记录 这里的记录只有一列 多列需要定义多个 VARCHAR需指定长度</span></div><div class="line"><span class="keyword">DECLARE</span> STYPE <span class="built_in">VARCHAR</span>(<span class="number">128</span>);  </div><div class="line"><span class="comment">-- 定义游标 使用游标进行遍历</span></div><div class="line"><span class="keyword">DECLARE</span> STYPE_CURSOR <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> DATA_TYPE <span class="keyword">FROM</span> BASE_STYPE_INFO <span class="keyword">WHERE</span> <span class="keyword">ID</span> &gt; <span class="number">1000000</span>;</div><div class="line"><span class="comment">-- 定义 结束标识DONE何时改变</span></div><div class="line"><span class="keyword">DECLARE</span> CONTINUE <span class="keyword">HANDLER</span> <span class="keyword">FOR</span> <span class="keyword">NOT</span> <span class="keyword">FOUND</span> <span class="keyword">SET</span> DONE = <span class="number">1</span>; </div><div class="line"></div><div class="line"><span class="comment">-- 打开游标</span></div><div class="line">OPEN STYPE_CURSOR;</div><div class="line"></div><div class="line"><span class="comment">-- 循环开始</span></div><div class="line">REPEAT</div><div class="line"><span class="comment">-- 可FETCH多列 需对应上</span></div><div class="line">FETCH STYPE_CURSOR INTO STYPE;</div><div class="line"><span class="comment">-- 结果集没读完则继续</span></div><div class="line">IF NOT DONE THEN</div><div class="line"><span class="comment">-- 假设这里需要做一下类型转换 使用CAST将字符转成数值</span></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> BASE_OTHER_TABLE(<span class="keyword">ID</span>, TYPE_NAME, CREATE_TIME) </div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">ID</span>+<span class="number">1000000</span> <span class="keyword">ID</span>, <span class="string">'TEST'</span> TYPE_NAME, <span class="number">1563445355</span> CREATE_TIME <span class="keyword">FROM</span> BASE_ANOTHER_TABLE</div><div class="line"><span class="keyword">WHERE</span> <span class="keyword">TYPE</span> = <span class="keyword">CAST</span>(STYPE <span class="keyword">AS</span> SIGNED);</div><div class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</div><div class="line">UNTIL DONE <span class="keyword">END</span> <span class="keyword">REPEAT</span>;</div><div class="line"></div><div class="line"><span class="comment">-- 关闭游标</span></div><div class="line">CLOSE STYPE_CURSOR;</div><div class="line"><span class="comment">-- 循环结束</span></div><div class="line"><span class="keyword">END</span> $$</div><div class="line"></div><div class="line">DELIMITER;<span class="comment">-- 结束符恢复</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">-- 调用存储过程</span></div><div class="line"><span class="keyword">CALL</span> SELECT_4_INSERT();</div><div class="line"></div><div class="line"><span class="comment">-- 若为临时存储过程 调用完删除</span></div><div class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> SELECT_4_INSERT;</div></pre></td></tr></table></figure></p><p>还有一种情况，将A表中的查询结果全部塞到B表中，只做一些字段匹配调整，可直接使用INSERT…SELECT…</p><p>A表中字段：ID FIRST_NAME LAST_NAME GENDER<br>B表中字段：ID NAME FLAG HOBBIES</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> BASE_B_INFO(<span class="keyword">ID</span>, NAM, FLAG, HOBBIES)</div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">ID</span>+<span class="number">1000000</span> <span class="keyword">ID</span>, <span class="keyword">CONCAT</span>(FIRST_NAME, LAST_NAME) <span class="keyword">NAME</span> , <span class="number">0</span> FLAG ,<span class="string">'无'</span> HOBBIES </div><div class="line"><span class="keyword">FROM</span> BASE_A_INFO</div></pre></td></tr></table></figure><p><hr></p><p>2017.12.23 00:13</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有这样一个需求，从A表中查询出结果，作为B表插入的查询条件，之后循环查询并插入。从网上看了些解决方案，这里写了一个存储过程的DEMO。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://JohnneyAnn.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="mysql" scheme="http://JohnneyAnn.github.io/tags/mysql/"/>
    
      <category term="存储过程" scheme="http://JohnneyAnn.github.io/tags/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>后焦虑思考</title>
    <link href="http://JohnneyAnn.github.io/2017/12/17/%E5%90%8E%E7%84%A6%E8%99%91%E6%80%9D%E8%80%83/"/>
    <id>http://JohnneyAnn.github.io/2017/12/17/后焦虑思考/</id>
    <published>2017-12-17T15:24:21.183Z</published>
    <updated>2017-12-17T15:24:21.179Z</updated>
    
    <content type="html"><![CDATA[<p>焦虑是不是这个时代的产物？<br>这周又体会到了焦虑，是什么导致了焦虑？你的焦虑来自于自身还是外界？<br>我生活在这个时代，很难去考证上个时代的人们是否同我一样有各种焦虑，也可能每个时代的焦虑都不一样，我想说的是我处在的焦虑，那就这个时代吧。<br><a id="more"></a></p><h1 id="焦虑"><a href="#焦虑" class="headerlink" title="焦虑"></a>焦虑</h1><p>个人认为，来自于自身的焦虑是自己能够去感知自己的不足而产生的焦虑，这种焦虑可能是正性的，能够意识到自己不足从而促进个人的提升，既然是可能，意味着也不排除破罐子破摔的情况存在。而来自外界的焦虑是别人向你灌输你存在不足从而促进你去接受这个思想而产生的焦虑，其中有一种情况很常见，大多是环境的影响或是商家的手段：“别人都在做而你没有或者你做的与别人不一样”。</p><br><p>举个例子，几个月前开始使用的一款app，得到。罗振宇老师创办的，提供的是知识服务，通俗点说是卖知识的。于我这个刚步入社会，眼界小的可怜的喽啰来说，说发现新大陆一点也不过分，早期可谓是如饥似渴，打开软件，启动图上显示的“和你一起终身学习、一起建设一所终生大学”，瞬间感觉自己有了文化，正在知识的海洋里翻滚。从小到大没有看过什么书，这里的一切都是新鲜的，可以看到很多的观点，也因此看完了罗振宇老师的书，我把时间安排的死死的。正如得到app的核心思想嘛，“利用碎片化时间终生学习”。公交车上、洗澡、上厕所、排队我都在听，每天充实的要死。几个月后，我也能跟你说说什么新奇的观点，可是我更焦虑了。这么多知识我怎么才能看的完？看完忘了怎么办？本想消除我无知的焦虑，却加剧了我的无知，带来了时间上的焦虑和生活上的疲惫。这时就有人发言了：“罗胖子啊，你这哪是卖知识，你这是在卖焦虑啊”。</p><br><p>这个例子我说的两种焦虑都包含，我不仅感受了焦虑也感受了疲惫。这个时候就该反思了，是罗胖子的说法对还是这个路人甲的发言对？我回顾了下，我是前期听罗胖子的，中期听路人甲的，后期决定中庸。都对，都不对。否则岂不是又陷入焦虑？来分析下，罗胖子要我们学习，学习是好事啊，我们就应该终身学习是吧，这是一个有经验的人对其他人的忠告；罗胖子也是个商人，无形之中给我们灌输的是“小笨蛋们，想变聪明嘛，用得到app才行啊！”，这与我们来说肯定觉得是不对的，但对于一个商人来说无可厚非；再看看路人甲，他说出来罗胖子作为商人的行为，很正确，问题在于如何去选择是他自己的事。</p><br><p>以上仅代表个人观点。“得到”现在还在我的手机里，我还在用，不同的是不再觉得看了“得到”就有文化（不被商家左右），就不傻了，而是把他当作一个渠道、一个娱乐方式，没有去刻意的使用，强迫自己今天必须要听多少。每个人情况都有所不同，你工作累了想放松你大可回来花半个小时听听舒缓的歌，强迫自己去接受知识带着负面情绪还怎么赚钱？还是要随心嘛。目前的时代确实是碎片化的，当“碎片化”被提及是，带来了电子书的回春，碎片化知识服务产业的兴起，电子书也不是单纯的看书了多了讲书，电台也开始有知识服务了，还有知乎一小时系列等等。有人说这个好，有人说那个好，不可能照单全收，否责又陷入焦虑了。知识是学不完的，不是说你没有使用某个app你就错过了一些知识，也不是你用了某个app就高人一等，每个人都有自己的选择，这类软件1-2个足以。最最主要的是你要选择你喜欢的软件，选择软件里提供的你感兴趣的内容，不要被别人左右。学你感兴趣的才是学习，你不知道想知道的才是知识。</p><br><p>我目前手机里有“微信读书”和“得到”，“微信读书”用的多，可以看到很多有趣的书，“得到”呢只偶尔无聊时使用它的“每天听本书”栏目，只是偶尔，有时间还是喜欢看而不是听。听的都是别人的见解，看的才能有自己的想法。</p><h1 id="公司团建前后"><a href="#公司团建前后" class="headerlink" title="公司团建前后"></a>公司团建前后</h1><h2 id="团建前"><a href="#团建前" class="headerlink" title="团建前"></a>团建前</h2><p>时间：2017.12.16 星期六 方山汽摩基地 冷但有阳光</p><br><p>这是来公司的第一次集体出去活动，自然不能缺席，也十分期待周六的活动。这是个令人高兴的事，但是如果周六时间用来团建，那本周的工作则需要在周六之前完成。从周会上来看，本周的工作完成肯定不会需要太长的时间，然而我已经不会再那么天真了（/手动摊手），早早就有了心里准备，活来了，焦虑也来了。是无知的焦虑，我一直觉得既然工作了就不应该有什么不会的，不会就去学呗，别人会自己也能吧，这次的活能够去了解其他部门的东西，还是觉得很有趣，后来严重受挫。老板和同事都在指点帮助我理解，我还是出错还是在纠结，时间花掉却没能输出成果或者说没能输出满意的结果。连续加了四晚的班，我想还有一部分时间是在焦虑，来自自身的焦虑。想把这件事完成的焦虑，还有其他事的焦虑，自己是否能胜任这个工作的焦虑，后而自身不足的焦虑。也希望我能够像理解“得到”式焦虑那样消除这些焦虑。</p><h2 id="团建中"><a href="#团建中" class="headerlink" title="团建中"></a>团建中</h2><p>去了有30多人吧，第一感觉：这是谁…我们部门的么。好在与我预想的一样，第一个活动是趣味游戏，于参加过上次联谊的我来说（/手动尴尬一把），这简直就是一个”神器“，能够最短时间放下大家的”偶像“包袱，打成一片。而且，做完还很暖和…</p><br><p>真人CS，没见过世面的人第一次玩，听说是激光枪，开始各种脑补炫酷的场景，到了现场第一感受，这怕是要拼一波演技咯。穿上装备，fire in the hole！还好，不全靠演技，被击中和击中都是有感应的，后来也有点套路。跑的很开心，大家都在笑，还有个别同事可能在地上打了个滚…有一点要吐槽的是场地太小了，那么多小房子，怎么不能进去捡装备呢！</p><br><p>中午来自助烧烤，以前大学团建户外烧烤是租的小炉子，看到眼前的大炉子心里竟然还有点爽，然后我就被浓烟熏的感动哭了。后来坐在炉子的角落，全程只翻了几次肉，后来炒了下鱿鱼，然后还吃着同事递过来的粮食，感谢勤劳的同事不杀之恩。后来，实在是这张吴彦祖的脸我还想要，离开了炉子到外面走了走。</p><br><p>强烈推荐跑跑卡丁车！三圈意犹未尽啊！虽说是老司机，但第一次开这种车，心里还是有点虚，第一圈摸清车的机制、路况，第二圈提速试着急转，第三圈就是放飞自我，虽说不计秋名山车神，也没有炫酷的漂移，但就很帅，总结一个字就是，稳！后来准备混着在上一次，还是下次吧，哈哈。</p><h2 id="团建后"><a href="#团建后" class="headerlink" title="团建后"></a>团建后</h2><p>坐着大巴回公司，路上感受着阳光的沐浴，天气是真的好。想着还有活还没做，就去了公司，写了一个小功能。人最害怕热闹过后的寂静，多愁善感的我一边感伤一边写着代码，然后点开闪烁的消息提醒，被怼了一通，内心是拒绝的，但确实是自己干的活，控制住情绪，准备与怼我者商讨解决方案，似乎他心中确实也有不满，顺着他来，等周一去解决吧。</p><br><p>周末算是一周工作的结束，可以去做自己想做的事，本该开心。但是，如果工作没有完成就不太开心了，这工作的事情没那么好忘，有人说周末应该吧工作忘了好好放松一把，但舒适总要付出代价，想想啊，这些没做完的事周一还是要去解决，还担心自己不一定能够解决，然后处在焦虑下过这个周末，赔了夫人又折兵。若本周的事本周全部能够完成，那该多好啊，开始也确实过过这样的日子。按理说，今日事当今日毕，可计划永赶不上变化，去解决一点再解决一点，希望能够越来越熟悉，早日得心应手。那时，或许还能谈谈追求。</p><h2 id="团结后之后"><a href="#团结后之后" class="headerlink" title="团结后之后"></a>团结后之后</h2><p>这时已经在家了，该是22点许，浑身酸痛，身体在说话：看你着运动缺乏的！坚持一件事很难，大学时跑步坚持了一个月有余，后因天气寒冷而放弃，而跑步这件事坚持三年确能毁于一月，我这坚持一月的怕是谈不上坚持了。读书是从小到大算的上坚持的第一件事，也后悔为何到现在才明白，耽误了这么久，那或许跑步我也能吧，不试试岂不是咸鱼？</p><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>啥展望，明天准备去接受摧残！！</p><h1 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h1><p>最后分享一下这周看的书，整理了一个脑图，关于咖啡的，有兴趣可以看看。</p><p></p><p>点击下面的链接即可。<br>脑图：<a href="http://naotu.baidu.com/file/26cc5fe4d5fe4d8135c7ade6b757ee12?token=2defa3ff44ce869c" target="_blank" rel="external">《咖啡原来是这样的》</a></p><p>有什么想法可以在下方评论。Night.</p><p><hr></p><p>2017.12.17 22:59</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;焦虑是不是这个时代的产物？&lt;br&gt;这周又体会到了焦虑，是什么导致了焦虑？你的焦虑来自于自身还是外界？&lt;br&gt;我生活在这个时代，很难去考证上个时代的人们是否同我一样有各种焦虑，也可能每个时代的焦虑都不一样，我想说的是我处在的焦虑，那就这个时代吧。&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://JohnneyAnn.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://JohnneyAnn.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="愚见" scheme="http://JohnneyAnn.github.io/tags/%E6%84%9A%E8%A7%81/"/>
    
  </entry>
  
  <entry>
    <title>机器学习实战（五）Logistic回归</title>
    <link href="http://JohnneyAnn.github.io/2017/12/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98%EF%BC%88%E4%BA%94%EF%BC%89Logistic%E5%9B%9E%E5%BD%92/"/>
    <id>http://JohnneyAnn.github.io/2017/12/01/机器学习实战（五）Logistic回归/</id>
    <published>2017-12-01T13:50:26.704Z</published>
    <updated>2017-12-01T13:50:26.704Z</updated>
    
    <content type="html"><![CDATA[<p>Logistic回归是一种简单的分类算法，提到“回归”，很多人可能觉得与分类没什么关系，Logistic回归通过对数据分类边界的拟合来实现分类。而“回归”也就意味着最佳拟合。要进行最佳拟合，则需要寻找到最佳的拟合参数，一些最优化方法就可以用于最佳回归系数的确定。<br><a id="more"></a></p><h1 id="Logistic回归"><a href="#Logistic回归" class="headerlink" title="Logistic回归"></a>Logistic回归</h1><p><strong>对书中代码做的修改：</strong></p><ul><li>1.修改plotBestFit（wei）参数名称plotBestFit（weights）</li><li>2.移除plotBestFit（）中weights=wei.getA()</li><li>3.分析数据画决策边界调用plotBestFit（weights）时传入weights.getA()，其中weight是gredAscent(dataArr,labelMat)方法的返回值</li></ul><h2 id="LogistiC-回归梯度上升优化算法"><a href="#LogistiC-回归梯度上升优化算法" class="headerlink" title="LogistiC 回归梯度上升优化算法"></a>LogistiC 回归梯度上升优化算法</h2><h3 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet</span><span class="params">()</span>:</span></div><div class="line">    dataMat = []</div><div class="line">    labelMat = []</div><div class="line">    fr = open(<span class="string">'F:\\study\\testSet.txt'</span>)</div><div class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</div><div class="line">        <span class="comment">#去除空格并拆分</span></div><div class="line">        lineArr = line.strip().split()</div><div class="line">        dataMat.append([<span class="number">1.0</span>, float(lineArr[<span class="number">0</span>]), float(lineArr[<span class="number">1</span>])])</div><div class="line">        labelMat.append(int(lineArr[<span class="number">2</span>]))</div><div class="line">    <span class="keyword">return</span> dataMat,labelMat</div></pre></td></tr></table></figure><h3 id="Sigmoid函数"><a href="#Sigmoid函数" class="headerlink" title="Sigmoid函数"></a>Sigmoid函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">sigmoid函数</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(inX)</span>:</span></div><div class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>/(<span class="number">1</span>+exp(-inX)))</div></pre></td></tr></table></figure><h3 id="LogistiC-梯度上升算法"><a href="#LogistiC-梯度上升算法" class="headerlink" title="LogistiC 梯度上升算法"></a>LogistiC 梯度上升算法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">gredAscent</span><span class="params">(dataMatIn, classLabels)</span>:</span></div><div class="line">    <span class="comment">#[[x,x,x],...]</span></div><div class="line">    dataMatrix = mat(dataMatIn)</div><div class="line">    <span class="comment">#将列表转换为矩阵再倒置</span></div><div class="line">    labelMat = mat(classLabels).transpose()</div><div class="line">    <span class="comment">#获取行列</span></div><div class="line">    m,n = shape(dataMatrix)</div><div class="line">    <span class="comment">#向目标移动的步长</span></div><div class="line">    alpha = <span class="number">0.001</span></div><div class="line">    <span class="comment">#迭代次数</span></div><div class="line">    maxCycles = <span class="number">500</span></div><div class="line">    <span class="comment">#回归系数 n=3行1列的单位数组</span></div><div class="line">    weights = ones((n,<span class="number">1</span>))</div><div class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(maxCycles):</div><div class="line">        <span class="comment">#h&gt;0.5 在右边 dataMatrix*weights矩阵相乘100行一列</span></div><div class="line">        <span class="comment">#每次计算所有样本点</span></div><div class="line">        h = sigmoid(dataMatrix*weights)</div><div class="line">        error = (labelMat-h);</div><div class="line">        <span class="comment">#w = w + α▽w f(w)</span></div><div class="line">        <span class="comment">#dataMatrix.transpose() 3行100列  error 100行1列  相乘后3，1</span></div><div class="line">        weights = weights + alpha * dataMatrix.transpose()*error</div><div class="line">    <span class="keyword">return</span> weights</div></pre></td></tr></table></figure><ul><li>1.解析文本，文本中有100个样本点，前两列代表点的数值型特征X1,X2，最后一列为分类标签</li><li>2.设置回归系数初始值为1（为单位矩阵，每个样本点对应一个回归系数，设置回归系数行数等于样本点的列数，实现倒置），步长为0.001，训练次数500</li><li>3.计算z=wTx,带入sigmod获取结果，将结果与分类标签计算误差值</li><li>4.根据误差值方向调整回归系数（梯度迭代公式，梯度简化为数据样本与错误量相乘[见上篇博客公式推导]）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">查看效果</span></div><div class="line"><span class="string">"""</span></div><div class="line">dataArr,labelMat = loadDataSet()</div><div class="line">weights = gredAscent(dataArr,labelMat)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">分析数据：画出决策边界</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotBestFit</span><span class="params">(weights)</span>:</span></div><div class="line">    dataMat,labelMat = loadDataSet()</div><div class="line">    dataArr = array(dataMat)</div><div class="line">    <span class="comment"># n = 100</span></div><div class="line">    n = shape(dataArr)[<span class="number">0</span>]</div><div class="line">    xcord1 = []; ycord1 = []</div><div class="line">    xcord2 = []; ycord2 = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">        <span class="keyword">if</span> int(labelMat[i]) == <span class="number">1</span>:</div><div class="line">            xcord1.append(dataArr[i, <span class="number">1</span>]); ycord1.append(dataArr[i,<span class="number">2</span>])</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            xcord2.append(dataArr[i, <span class="number">1</span>]); ycord2.append(dataArr[i,<span class="number">2</span>])</div><div class="line">    <span class="comment"># 创建画布</span></div><div class="line">    fig = plt.figure()</div><div class="line">    ax = fig.add_subplot(<span class="number">111</span>)</div><div class="line">    <span class="comment"># 画标签为1的点</span></div><div class="line">    ax.scatter(xcord1, ycord1, s=<span class="number">30</span>, c=<span class="string">'red'</span>, marker=<span class="string">'p'</span>)</div><div class="line">    <span class="comment"># 画标签为0的点</span></div><div class="line">    ax.scatter(xcord2, ycord2, s=<span class="number">30</span>, c=<span class="string">'green'</span>)</div><div class="line">    <span class="comment">#创建决策边界线</span></div><div class="line">    x = arange(<span class="number">-3.0</span>, <span class="number">3.0</span>, <span class="number">0.1</span>)</div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    设置sigmod函数值为0,0是两个分类的分界处，可解出x，y的关系式</span></div><div class="line"><span class="string">    """</span></div><div class="line">    <span class="comment"># 0 = w0*x0 + w1*x + w2*y  =&gt;  y = -(w0 + w1*x)/w2</span></div><div class="line">    y = (-weights[<span class="number">0</span>]-weights[<span class="number">1</span>]*x)/weights[<span class="number">2</span>] <span class="comment">#最佳拟合线</span></div><div class="line">    ax.plot(x,y)</div><div class="line">    plt.xlabel(<span class="string">'X1'</span>);plt.ylabel(<span class="string">'X2'</span>);</div><div class="line">    plt.show()</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">查看效果</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</div><div class="line"><span class="comment"># 传入返回的回归系数(书中有误，因此修改了plotBestFit的传参，也为了后面随机梯度可共用</span></div><div class="line"><span class="comment">#另外需要定义weights将gredAscent的值赋给weights)</span></div><div class="line">%matplotlib inline</div><div class="line"><span class="comment"># getA()将自身矩阵转化为ndarray类型的变量，等价于asarray(self)</span></div><div class="line">plotBestFit(weights.getA())</div></pre></td></tr></table></figure><p><img src="/img/logistic/1.png" alt="分析数据"></p><h2 id="随机梯度上升算法"><a href="#随机梯度上升算法" class="headerlink" title="随机梯度上升算法"></a>随机梯度上升算法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">一次仅用一个样本点来更新回归系数</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">stocGradAscent0</span><span class="params">(dataMatrix, classLabels)</span>:</span></div><div class="line">    m,n=shape(dataMatrix)</div><div class="line">    alpha = <span class="number">0.01</span></div><div class="line">    weights = ones(n)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</div><div class="line">        <span class="comment">#每次计算一个样本点</span></div><div class="line">        h = sigmoid(sum(dataMatrix[i]*weights))</div><div class="line">        error = classLabels[i] - h</div><div class="line">        weights = weights + alpha*error*dataMatrix[i]</div><div class="line">    <span class="keyword">return</span> weights</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">查看效果</span></div><div class="line"><span class="string">"""</span></div><div class="line">dataArr,labelMat = loadDataSet()</div><div class="line">weights = stocGradAscent0(array(dataArr),labelMat)</div><div class="line">plotBestFit(weights)</div></pre></td></tr></table></figure><p><img src="/img/logistic/2.png" alt="分析数据"></p><h2 id="改进的随机梯度上升算法"><a href="#改进的随机梯度上升算法" class="headerlink" title="改进的随机梯度上升算法"></a>改进的随机梯度上升算法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">改进的随机梯度上升算法</span></div><div class="line"><span class="string">alpha在每次迭代的时候都会调整，随着迭代次数不断减小，但永远不会到0</span></div><div class="line"><span class="string">每次从样本中随机取出一个样本更新回归系数，之后将改值从列表中删除，进行下次迭代</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">stocGradAscent1</span><span class="params">(dataMatrix, classLabels, numIter=<span class="number">150</span>)</span>:</span></div><div class="line">    m,n = shape(dataMatrix)</div><div class="line">    weights = ones(n)</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(numIter):</div><div class="line">        <span class="comment"># 每个样本的编号[0,..,99]</span></div><div class="line">        dataIndex = range(m)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</div><div class="line">            <span class="string">"""</span></div><div class="line"><span class="string">            步长alpha每次迭代时需要调整，每次减少1/(i+j)</span></div><div class="line"><span class="string">            档j&lt;&lt;max(i),alpha就不是严格下降的。</span></div><div class="line"><span class="string">            避免参数严格下降也常见于模拟退火算法（SAA)等其他优化算法中</span></div><div class="line"><span class="string">            """</span></div><div class="line">            alpha = <span class="number">4</span>/(<span class="number">1.0</span>+j+i)+<span class="number">0.01</span></div><div class="line">            <span class="comment"># numpy.random.uniform(low,high,size)在给定区间[0,100)内随机取样，注意是左闭右开</span></div><div class="line">            <span class="comment"># size输出样本数目，int或元组，缺省时输出一个值</span></div><div class="line">            randIndex = int(random.uniform(<span class="number">0</span>,len(dataIndex)))</div><div class="line">            <span class="comment"># 求和 即计算z = w0x0+w1*x1+w2*x2  随机选取样本计算h</span></div><div class="line">            h = sigmoid(sum(dataMatrix[randIndex]*weights))</div><div class="line">            error = classLabels[randIndex] - h</div><div class="line">            weights = weights + alpha * error * dataMatrix[randIndex]</div><div class="line">            <span class="comment"># 样本被使用后去除 在此次迭代内dataIndex长度每次减1</span></div><div class="line">            <span class="keyword">del</span>(dataIndex[randIndex])</div><div class="line">    <span class="keyword">return</span> weights</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">查看效果</span></div><div class="line"><span class="string">"""</span></div><div class="line">dataArr,labelMat = loadDataSet()</div><div class="line">weights = stocGradAscent1(array(dataArr),labelMat)</div><div class="line">plotBestFit(weights)</div></pre></td></tr></table></figure><p><img src="/img/logistic/3.png" alt="分析数据"></p><h2 id="从疝气病症预测病马的死亡率"><a href="#从疝气病症预测病马的死亡率" class="headerlink" title="从疝气病症预测病马的死亡率"></a>从疝气病症预测病马的死亡率</h2><h3 id="处理数据中的缺失值"><a href="#处理数据中的缺失值" class="headerlink" title="处理数据中的缺失值"></a>处理数据中的缺失值</h3><p><strong>可选的做法</strong></p><blockquote><p>使用可用特征的均值来填补缺失值；<br>使用特殊值来填补缺失值，如-1;<br>忽略有缺失值的样本；<br>使用相似样本的均值添补缺失值；<br>使用另外的机器学习算法预测缺失值。</p></blockquote><p>numpy不允许包含缺失值，选择实数0来替换所有缺失值，恰好能适用于Logistic回归<br>我们需要的是一个在更新是不会影响系数的值，根据回归系数的更新公式<br>w = w + a <em> e </em> dataMatrix[randIndex],若dataMatrix的某特征对应值为0,则系数不做更新w=w，另外sigmoid(0)=0.5，对结果的预测不具有任何的倾向性</p><h3 id="Logistic回归分类函数"><a href="#Logistic回归分类函数" class="headerlink" title="Logistic回归分类函数"></a>Logistic回归分类函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">classifyVector</span><span class="params">(inX, weights)</span>:</span></div><div class="line">    prob = sigmoid(sum(inX*weights))</div><div class="line">    <span class="keyword">if</span> prob &gt; <span class="number">0.5</span>: <span class="keyword">return</span> <span class="number">1.0</span></div><div class="line">    <span class="keyword">else</span>: <span class="keyword">return</span> <span class="number">0.0</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">colicTest</span><span class="params">()</span>:</span></div><div class="line">    frTrain = open(<span class="string">'F:\study\horseColicTraining.txt'</span>)</div><div class="line">    frTest = open(<span class="string">'F:\study\horseColicTest.txt'</span>)</div><div class="line">    trainingSet = []; trainingLabels = []</div><div class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> frTrain.readlines():</div><div class="line">        currLine = line.strip().split(<span class="string">'\t'</span>)</div><div class="line">        lineArr = []</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">21</span>):</div><div class="line">            lineArr.append(float(currLine[i]))</div><div class="line">        trainingSet.append(lineArr)</div><div class="line">        trainingLabels.append(float(currLine[<span class="number">21</span>]))</div><div class="line">    trainWeights = stocGradAscent1(array(trainingSet), trainingLabels, <span class="number">500</span>)</div><div class="line">    errorCount = <span class="number">0</span>; numTestVec = <span class="number">0.0</span></div><div class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> frTest.readlines():</div><div class="line">        numTestVec += <span class="number">1.0</span></div><div class="line">        currLine = line.strip().split(<span class="string">'\t'</span>)</div><div class="line">        lineArr = []</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">21</span>):</div><div class="line">            lineArr.append(float(currLine[i]))</div><div class="line">        <span class="keyword">if</span> int(classifyVector(array(lineArr), trainWeights)) != int(currLine[<span class="number">21</span>]):</div><div class="line">            errorCount += <span class="number">1</span></div><div class="line">    errorRate = (float(errorCount)/numTestVec)</div><div class="line">    <span class="keyword">print</span> <span class="string">"the error rate of this test is: %f"</span> % errorRate</div><div class="line">    <span class="keyword">return</span> errorRate</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiTest</span><span class="params">()</span>:</span></div><div class="line">    numTests = <span class="number">10</span>; errorSum=<span class="number">0.0</span></div><div class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(numTests):</div><div class="line">        errorSum += colicTest()</div><div class="line">    <span class="keyword">print</span> <span class="string">"after %d iterations the average error rate is: %f"</span> % (numTests, errorSum/float(numTests))</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">运行时报D:\Anaconda2\lib\site-packages\ipykernel\__main__.py:5: </span></div><div class="line"><span class="string">RuntimeWarning: overflow encountered in exp警告</span></div><div class="line"><span class="string">说明计算的数据结果溢出了，忽略也无妨，查过说可以调整sigmoid函数，</span></div><div class="line"><span class="string">使用longfloat()来解决溢出，但没有解决，还在寻找解决办法。。</span></div><div class="line"><span class="string">"""</span></div><div class="line">multiTest()</div></pre></td></tr></table></figure><pre><code>D:\Anaconda2\lib\site-packages\ipykernel\__main__.py:5: RuntimeWarning: overflow encountered in expthe error rate of this test is: 0.298507the error rate of this test is: 0.402985the error rate of this test is: 0.268657the error rate of this test is: 0.298507the error rate of this test is: 0.283582the error rate of this test is: 0.402985the error rate of this test is: 0.388060the error rate of this test is: 0.328358the error rate of this test is: 0.388060the error rate of this test is: 0.417910after 10 iterations the average error rate is: 0.347761</code></pre><h2 id="总结（来自书中）"><a href="#总结（来自书中）" class="headerlink" title="总结（来自书中）"></a>总结（来自书中）</h2><blockquote><p>Logistic回归的目的是寻找一个非线性函数sigmoid的最佳拟合参数，求解过程可以由最优化<br>算法来完成。在最优化算法中，最常用的就是梯度上升算法，而梯度上升算法又可以简化为随机<br>梯度上升算法。<br>随机梯度上升算法与梯度上升算法的效果相当，但占用更少的计算资源。此外，随机梯度上<br>升是一个在线算法，它可以在新数据到来时就完成参数更新，而不需要重新读取整个数据集来进<br>行批处理运算。<br>机器学习的一个重要问题就是如何处理缺失数据。这个问题没有标准答案，取决于实际应用<br>中的需求。现有一些解决方案，每种方案都各有优缺点。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Logistic回归是一种简单的分类算法，提到“回归”，很多人可能觉得与分类没什么关系，Logistic回归通过对数据分类边界的拟合来实现分类。而“回归”也就意味着最佳拟合。要进行最佳拟合，则需要寻找到最佳的拟合参数，一些最优化方法就可以用于最佳回归系数的确定。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://JohnneyAnn.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="机器学习" scheme="http://JohnneyAnn.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Python" scheme="http://JohnneyAnn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Logistic回归部分公式推导</title>
    <link href="http://JohnneyAnn.github.io/2017/11/27/Logistic%E5%9B%9E%E5%BD%92%E9%83%A8%E5%88%86%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC/"/>
    <id>http://JohnneyAnn.github.io/2017/11/27/Logistic回归部分公式推导/</id>
    <published>2017-11-27T13:56:01.420Z</published>
    <updated>2017-11-27T13:56:01.420Z</updated>
    
    <content type="html"><![CDATA[<p>代码的转换跳跃太大，还得自己去推到一边才知道下句代码为什么这样写。<br>数学：你还是不是栽在我手里！<br><a id="more"></a></p><h1 id="直接上图片"><a href="#直接上图片" class="headerlink" title="直接上图片"></a>直接上图片</h1><p><img src="/img/logistic/logistic.jpg" alt="回归公式推倒"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代码的转换跳跃太大，还得自己去推到一边才知道下句代码为什么这样写。&lt;br&gt;数学：你还是不是栽在我手里！&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://JohnneyAnn.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="机器学习" scheme="http://JohnneyAnn.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
