<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>安阳</title>
  
  <subtitle>若真的喜欢，就别抗拒遗憾</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://JohnneyAnn.github.io/"/>
  <updated>2017-09-13T04:31:53.070Z</updated>
  <id>http://JohnneyAnn.github.io/</id>
  
  <author>
    <name>安 阳</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>测试加密访问</title>
    <link href="http://JohnneyAnn.github.io/2017/09/13/testPassword/"/>
    <id>http://JohnneyAnn.github.io/2017/09/13/testPassword/</id>
    <published>2017-09-13T04:31:53.206Z</published>
    <updated>2017-09-13T04:31:53.070Z</updated>
    
    <content type="html"><![CDATA[<p>这是用来测试文章加密访问的。</p><a id="more"></a><p>这是用来测试文章加密访问的。<br>这是用来测试文章加密访问的。<br>这是用来测试文章加密访问的。<br>这是用来测试文章加密访问的。<br>这是用来测试文章加密访问的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是用来测试文章加密访问的。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://JohnneyAnn.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Test" scheme="http://JohnneyAnn.github.io/tags/Test/"/>
    
  </entry>
  
  <entry>
    <title>机器学习实战系列</title>
    <link href="http://JohnneyAnn.github.io/2017/09/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97/"/>
    <id>http://JohnneyAnn.github.io/2017/09/09/机器学习实战系列/</id>
    <published>2017-09-08T16:18:29.670Z</published>
    <updated>2017-09-08T16:18:29.662Z</updated>
    
    <content type="html"><![CDATA[<p>人生苦短，我用Python。</p><p>Python是门优雅的语言，在机器学习领域有着很高的造诣，虽然不太会，边写边学吧。</p><p>这一系列是我在学习《机器学习实战》这本书记的笔记，主要是代码，另外给这些代码加了些自己的注释，包括Python的api用法、某些科学计算库的用法、还有一些自己的理解。希望大家来指正，共同学习。</p><a id="more"></a><p>先说说这本书，这本书相对来说比较适合初学者。很多编程类书籍在读的时候很容易被某个地方卡住，经常不是缺这个就缺那个，书上还没有告诉你怎么处理，百度有时也找不到好的答案，这对于我这种咸鱼实在是不和善。对，这本书目前为止还没有出现过这个问题，因此我觉得它是适合的。</p><p>读这本书的时候，最大的感触是：难的不是语言，是数学。目前用到的像高数、线性代数、概率论还有信息论，我相信后面还有更多。可怕！抽自己一巴掌，大学学的都还差不多了！还有就是数学思想到编程思想的转化，比如我们利用某个数学模型来构建这个算法，真正写到程序里可能换一种方法，用的还是那个模型但需要找到合适的“替代品”来描述它，这对我来说也是比较难的。</p><p>于是我想给这些东西记下来，当自己能够去理解这些。这次先码四篇，后面学习的时候都会记录，之后再一并码上。</p><p>使用的环境为Anaconda,jupyter。很好用，jupyter很好上手。</p><p>数学真的要好好学！！！！！！！！！！！！！！！！！</p><p>这里是这一系列的地址：</p><p><a href="http://JohnneyAnn.github.io/2017/09/08/机器学习实战（四）朴素贝叶斯（NaivaBayes）/">机器学习实战（四）朴素贝叶斯（NaivaBayes）</a></p><p><a href="http://JohnneyAnn.github.io/2017/09/08/机器学习实战（三）决策树/">机器学习实战（三）决策树</a></p><p><a href="http://JohnneyAnn.github.io/2017/09/08/机器学习实战（二）k-近邻算法/">机器学习实战（二）k-近邻算法</a></p><p><a href="http://JohnneyAnn.github.io/2017/09/08/机器学习实战（一）NumPy函数库基础/">机器学习实战（一）NumPy函数库基础</a></p><p>学习使我感到快乐：）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生苦短，我用Python。&lt;/p&gt;
&lt;p&gt;Python是门优雅的语言，在机器学习领域有着很高的造诣，虽然不太会，边写边学吧。&lt;/p&gt;
&lt;p&gt;这一系列是我在学习《机器学习实战》这本书记的笔记，主要是代码，另外给这些代码加了些自己的注释，包括Python的api用法、某些科学计算库的用法、还有一些自己的理解。希望大家来指正，共同学习。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://JohnneyAnn.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="机器学习" scheme="http://JohnneyAnn.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Python" scheme="http://JohnneyAnn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github搭建个人博客</title>
    <link href="http://JohnneyAnn.github.io/2017/09/09/Hexo+Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://JohnneyAnn.github.io/2017/09/09/Hexo+Github搭建个人博客/</id>
    <published>2017-09-08T16:15:48.543Z</published>
    <updated>2017-09-08T16:15:48.527Z</updated>
    
    <content type="html"><![CDATA[<p>经常遇到这样的问题，学习搭建一个新的环境，在网上查阅很多资料搭成功了，可是第二次搭全忘了还得重复之前的操作，于是决定养成记录的习惯。不光是记录自己的学习笔记，也想与别人分享一些东西，有个博客还是不错的。<br><a id="more"></a></p><p style="text-indent:2em">我用过几个用于记录的软件或网站，更多的是记录了一些学习笔记，像是印象笔记、CSDN、简书等。这个有一点不好，那终究还是别人的东西，写点学习笔记还行，有的时候自己想写点私人的东西就不是太合适，我想做一个个人博客。</p><br><p style="text-indent:2em">行啊，作为一个程序员那就干吧，不就是写一个博客嘛。干的过程中感受到现实的残酷（尴尬脸），苦于自己是后端程序员，界面做的丑的不能看，挣扎了许久遇到了HEXO。</p><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></blockquote><p style="text-indent:2em">Hexo、jekyll、wordpress、jpress都是快速blog生成工具，我只用过hexo，就说说怎么搭建的（-. -我觉得HEXO还是比较好用的），大家倒可以挑自己喜欢的。</p><br><p style="text-indent:2em">第一次搭建的时候实在windows下搭建的（台式电脑），这导致了一个问题，更新博客得把我的电脑抱着走，因为本地仓库在那啊，后来就决定把博客迁移到服务器(因为迁移，所以博客的一些统计数据清零了)，这样只要有XShell到哪都能发博。所以这次所说的博客搭建是基于Ubuntu16.04x64系统搭建的，服务器是在阿里买的，当然腾讯也可以，一直喜欢用Ubuntu，而且阿里云会预装一些软件很方便。</p><br><p style="text-indent:2em">扯了这么多，步入正文吧。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装NodeJS"><a href="#安装NodeJS" class="headerlink" title="安装NodeJS"></a>安装NodeJS</h3><p>Hexo是基于Nodejs的，所以当然要装啦。使用apt-get 安装的nodejs版本过老，会导致安装hexo的时候出问题。<br>官方推荐的安装方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -</div><div class="line">sudo apt-get install -y nodejs</div></pre></td></tr></table></figure></p><h3 id="安装npm"><a href="#安装npm" class="headerlink" title="安装npm"></a>安装npm</h3><p>待会要用它下载hexo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install npm</div></pre></td></tr></table></figure></p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>一个功能强大的静态网站生成系统<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo npm install hexo-cli -g</div></pre></td></tr></table></figure></p><p>等待安装完成吧。</p><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><h3 id="Github帐号"><a href="#Github帐号" class="headerlink" title="Github帐号"></a>Github帐号</h3><p>你这博客是要塞到Github上的，没账号可不行。自己百度注册吧。连接在此：<a href="https://github.com/" target="_blank" rel="external">Github</a>。</p><h3 id="在Github建一个远程仓库"><a href="#在Github建一个远程仓库" class="headerlink" title="在Github建一个远程仓库"></a>在Github建一个远程仓库</h3><p>你在本地编辑的博客需要部署到这个地方，当然，这里hexo会帮你一键部署，但你得给它一个仓库。<br>在你的Github主页点击New repository,到下面这个页面，填写仓库名字，这个不能乱填。<br><img src="/img/hexoblog/newRes.png" alt="新建仓库"><br>我的Github用户名叫JohnneyAnn，那就得取名JohnneyAnn.github.io，必须！</p><h3 id="给你的服务器安装git"><a href="#给你的服务器安装git" class="headerlink" title="给你的服务器安装git"></a>给你的服务器安装git</h3><p>首先，确认你的系统是否已安装git，可以通过git指令进行查看，如果没有，输入下面指令进行安装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install git</div></pre></td></tr></table></figure></p><h3 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h3><p>安装完成后需要配置git，就是配置你的用户名还有邮箱（以我的为例）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name &quot;JohnneyAnn&quot;</div><div class="line">git config --global user.eamil &quot;604718423@qq.com&quot;</div></pre></td></tr></table></figure></p><h3 id="创建公钥"><a href="#创建公钥" class="headerlink" title="创建公钥"></a>创建公钥</h3><p>配置完成后，需要创建验证用的公钥，因为git是通过ssh的方式访问资源库的，所以需要在本地创建验证用的文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -C &apos;604718423@qq.com&apos; -t rsa</div></pre></td></tr></table></figure></p><p>RSA是一种加密方式，执行这个命令后会在用户目录~/.ssh/下建立相应的密钥文件。这一步创建会让你填入两次信息，不用管直接回车。</p><h3 id="上传公钥"><a href="#上传公钥" class="headerlink" title="上传公钥"></a>上传公钥</h3><p>创建完成了，你得让github知道啊。<br>进入公钥文件夹：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd ~/.ssh</div></pre></td></tr></table></figure></p><p>使用cat命令查看公钥：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat id_rsa.pub</div></pre></td></tr></table></figure></p><p>把这个文件所有的内容复制，接着去github，进入个人主页点击Edit profile之后点击SSH and GPG keys<br><img src="/img/hexoblog/sshkeys.png" alt="上传公钥"><br>点击New SSH key，名字随便去，然后把你复制的内容填进去报错就行了。</p><h3 id="测试是否连通"><a href="#测试是否连通" class="headerlink" title="测试是否连通"></a>测试是否连通</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -T git@github.com</div></pre></td></tr></table></figure><p>出现下面这个就ok了。<br><img src="/img/hexoblog/testssh.png" alt="测试SSH"><br>我这不是第一次，所以只有一行，第一次应该有三行提示，反正出现“Hi 你的名字！”就行了。</p><h2 id="开始hexo吧"><a href="#开始hexo吧" class="headerlink" title="开始hexo吧"></a>开始hexo吧</h2><h3 id="新建一个博客"><a href="#新建一个博客" class="headerlink" title="新建一个博客"></a>新建一个博客</h3><p>选一个文件夹吧，我去的是/home文件夹下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd /home</div><div class="line">hexo init myBlog</div></pre></td></tr></table></figure></p><p>hexo init myBlog就是新建一个博客，myBlog是你本地博客的文件夹名，可以随便取名，之后会去下载所需的东西。<br>下载完成后进入myblog文件夹：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd blog</div></pre></td></tr></table></figure></p><p>文件夹结构如下，简单说下主要文件：<br><img src="/img/hexoblog/file.png" alt="文件结构"><br>_config.yml文件是主要的配置文件，就是你网站的一些信息以及部署的仓库。文件底部可配置要部署的仓库：<br><img src="/img/hexoblog/hexoconfig2.png" alt="文件结构"><br>themes文件夹存放是的是博客主题样式，在知乎上看到一些，可在这里选择<a href="https://www.zhihu.com/question/24422335" target="_blank" rel="external">知乎:有哪些好看的 Hexo 主题？</a>。我选的是hexo-theme-spfk，去github上下载下来，放到themes文件夹下即可，你可以选择你喜欢的主题。<br>每个主题的文件夹下也有一个_config.yml配置文件，配置页面的，具体的配置以后有空会单独写一篇博客。</p><h3 id="编译博客"><a href="#编译博客" class="headerlink" title="编译博客"></a>编译博客</h3><p>可以看到，hexo生成的文件夹离得内容并不是html，所以我们需要编译它（可简写为 hexo g）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd /home</div><div class="line">hexo generate</div></pre></td></tr></table></figure></p><h3 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h3><p>根据_config.yml最后面的配置将博客部署到github上，只要你配置好了hexo会帮你一键部署。<br>部署之前需要安装hexo-deployer-Git（不然会出现ERROR Deployer not found: git）。<br>安装：hexo-deployer-Git<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p><p>好了可以部署了（可简写为 hexo d）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo deploy</div></pre></td></tr></table></figure></p><p>当然你可以将编译和部署一起来（生成并发布）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo generate -d</div></pre></td></tr></table></figure></p><p>部署完成后在浏览器输入JohnneyAnn.github.io（输入你实际的名字）即可访问你的博客，当然还是希望你能给先配置你自己的网站，填写这些配置很简单在网上都能够找到方法，后期我会具体写一下，今天这里有点多了。另外，大家肯定不愿意输入这个网址进入自己的博客，所以后面还会告诉大家如何将自己的域名解析到这个地址以及相关的配置，慢慢来。</p><h3 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h3><p>你肯定想修改后先看看效果再部署把（可简写为 hexo s）:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo server</div></pre></td></tr></table></figure></p><p>之后在浏览器输入，IP:4000就可以访问了（IP是你服务器的实际ip）。<br>crtl+c终止预览。</p><h3 id="其他（MarkDown）"><a href="#其他（MarkDown）" class="headerlink" title="其他（MarkDown）"></a>其他（MarkDown）</h3><p>Hexo里面的博客都是使用markdown语法的，其实也是个文本文件，后缀名为.md，它是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式，所以使用它来生成html很方便，语法也很简单，这里提供一个链接可以学习一下：<a href="http://www.jianshu.com/p/q81RER" target="_blank" rel="external">简书:献给写作者的 Markdown 新手指南</a>。MarkDown用一般的文本编辑器就可以编写，如果想一边写一边预览，可以尝试下MarkdownPad 2这个软件。</p><p><hr><br>哇，写了这么多，好累啊，下面有打赏(害羞脸)。<br>推荐阅读：<a href="http://JohnneyAnn.github.io/2017/09/08/WhatHappenedOnTheRoadOfHeifei/">生活:回合肥路上发生的事</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经常遇到这样的问题，学习搭建一个新的环境，在网上查阅很多资料搭成功了，可是第二次搭全忘了还得重复之前的操作，于是决定养成记录的习惯。不光是记录自己的学习笔记，也想与别人分享一些东西，有个博客还是不错的。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://JohnneyAnn.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="hexo" scheme="http://JohnneyAnn.github.io/tags/hexo/"/>
    
      <category term="Github" scheme="http://JohnneyAnn.github.io/tags/Github/"/>
    
      <category term="记录" scheme="http://JohnneyAnn.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>机器学习实战（四）朴素贝叶斯（NaivaBayes）</title>
    <link href="http://JohnneyAnn.github.io/2017/09/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98%EF%BC%88%E5%9B%9B%EF%BC%89%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%EF%BC%88NaivaBayes%EF%BC%89/"/>
    <id>http://JohnneyAnn.github.io/2017/09/08/机器学习实战（四）朴素贝叶斯（NaivaBayes）/</id>
    <published>2017-09-08T14:13:02.608Z</published>
    <updated>2017-09-08T14:13:02.608Z</updated>
    
    <content type="html"><![CDATA[<p>基于概率论的分类方法：朴素贝叶斯。（条件概率）</p><p>朴素贝叶斯：朴素贝叶斯是一种简单但是非常强大的线性分类器。它在垃圾邮件分类，疾病诊断中都取得了很大的成功。它只所以称为朴素，是因为它假设特征之间是相互独立的，但是在现实生活中，这种假设基本上是不成立的。那么即使是在假设不成立的条件下，它依然表现的很好，尤其是在小规模样本的情况下。但是，如果每个特征之间有很强的关联性和非线性的分类问题会导致朴素贝叶斯模型有很差的分类效果。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">数据集</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet</span><span class="params">()</span>:</span></div><div class="line">    postingList=[[<span class="string">'my'</span>, <span class="string">'dog'</span>, <span class="string">'has'</span>, <span class="string">'flea'</span>, <span class="string">'problems'</span>, <span class="string">'help'</span>, <span class="string">'please'</span>],</div><div class="line">                 [<span class="string">'maybe'</span>, <span class="string">'not'</span>, <span class="string">'take'</span>, <span class="string">'him'</span>, <span class="string">'to'</span>, <span class="string">'dog'</span>, <span class="string">'park'</span>, <span class="string">'stupid'</span>],</div><div class="line">                 [<span class="string">'my'</span>, <span class="string">'dalmation'</span>, <span class="string">'is'</span>, <span class="string">'so'</span>, <span class="string">'cute'</span>, <span class="string">'I'</span>, <span class="string">'love'</span>, <span class="string">'him'</span>],</div><div class="line">                 [<span class="string">'stop'</span>, <span class="string">'posting'</span>, <span class="string">'stupid'</span>, <span class="string">'worthless'</span>, <span class="string">'garbage'</span>],</div><div class="line">                 [<span class="string">'mr'</span>, <span class="string">'licks'</span>, <span class="string">'ate'</span>, <span class="string">'my'</span>, <span class="string">'steak'</span>, <span class="string">'how'</span>, <span class="string">'to'</span>, <span class="string">'stop'</span>, <span class="string">'him'</span>],</div><div class="line">                 [<span class="string">'quit'</span>, <span class="string">'buying'</span>, <span class="string">'worthless'</span>, <span class="string">'dog'</span>, <span class="string">'food'</span>, <span class="string">'stupid'</span>]]</div><div class="line">    <span class="comment"># 0代表正常言论，1代表侮辱性</span></div><div class="line">    classVec = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]</div><div class="line">    <span class="keyword">return</span> postingList,classVec</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">createVocabList</span><span class="params">(dataSet)</span>:</span></div><div class="line">    <span class="comment">#创建一个空集</span></div><div class="line">    vocabSet = set([])</div><div class="line">    <span class="comment">#将文档中的词存放到set，不重复</span></div><div class="line">    <span class="keyword">for</span> document <span class="keyword">in</span> dataSet:</div><div class="line">        <span class="comment">#创建两个集合的并集</span></div><div class="line">        vocabSet = vocabSet | set(document)</div><div class="line">    <span class="keyword">return</span> list(vocabSet)</div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">词集模型(set-of-words) 每个词出现一次</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">setOfWords2Vec</span><span class="params">(vocabList, inputSet)</span>:</span></div><div class="line">    <span class="comment"># 创建一个其中所含袁术都为0的向量</span></div><div class="line">    returnVec = [<span class="number">0</span>]*len(vocabList)</div><div class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> inputSet:</div><div class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> vocabList:</div><div class="line">            <span class="comment"># 若存在就记为1</span></div><div class="line">            returnVec[vocabList.index(word)] = <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">print</span> <span class="string">"the word: %s is not in my vocabulary!"</span> % word</div><div class="line">    <span class="keyword">return</span> returnVec</div><div class="line"></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">词袋模型(bag-of-words model) 每个词出现多次</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bagOfWords2VecMN</span><span class="params">(vocabList, inputSet)</span>:</span></div><div class="line">    returnVec = [<span class="number">0</span>]*len(vocabList)</div><div class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> inputSet:</div><div class="line">        <span class="comment"># 每当遇到一个单词 就会增加词向量中的对应值，而不是设为1</span></div><div class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> vocabList:</div><div class="line">            returnVec[vocabList.index(word)] += <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> returnVec</div><div class="line"></div><div class="line"></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">朴素贝叶斯分类器训练函数</span></div><div class="line"><span class="string">trainMatrix:文档矩阵</span></div><div class="line"><span class="string">trainCategory:由每篇文档类别标签所构成的向量</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">trainNB0</span><span class="params">(trainMatrix,trainCategory)</span>:</span></div><div class="line">    <span class="comment">#print trainMatrix</span></div><div class="line">    <span class="comment">#print trainCategory</span></div><div class="line">    <span class="comment">#有多少个文件</span></div><div class="line">    numTrainDocs = len(trainMatrix)</div><div class="line">    <span class="comment">#print numTrainDocs</span></div><div class="line">    <span class="comment">#获取训练词有多少个</span></div><div class="line">    numWords = len(trainMatrix[<span class="number">0</span>])</div><div class="line">    <span class="comment"># 统计trainCategory中1的个数，因为里面只有1,0</span></div><div class="line">    <span class="comment">#文档概率</span></div><div class="line">    pAbusive = sum(trainCategory)/float(numTrainDocs)</div><div class="line">    <span class="comment"># 初始化概率</span></div><div class="line">    p0Num = ones(numWords)<span class="comment">#修改前：zeros(numWords) 构造0矩阵，所有的值都为0</span></div><div class="line">    p1Num = ones(numWords)<span class="comment">#修改前：zeros(numWords)</span></div><div class="line">    p0Denom = <span class="number">2.0</span> <span class="comment">#分母 修改前：0.0</span></div><div class="line">    p1Denom = <span class="number">2.0</span> <span class="comment">#修改前：0.0</span></div><div class="line">    <span class="comment">#遍历训练集trainMatrix中所有文档，一旦某个词在某一文档中出现，对应个数(p1Num侮辱性/p0Num正常)就+1 </span></div><div class="line">    <span class="comment">#-而且在所有文档中，该文档的总词数也相应+1 ? 统计总侮辱性次数</span></div><div class="line">    <span class="comment">#print numTrainDocs</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numTrainDocs):</div><div class="line">        <span class="keyword">if</span> trainCategory[i] == <span class="number">1</span>:</div><div class="line">            <span class="comment">#向量相加</span></div><div class="line">            p1Num += trainMatrix[i]</div><div class="line">            p1Denom += sum(trainMatrix[i]) <span class="comment"># 总侮辱性词数  </span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            p0Num += trainMatrix[i]</div><div class="line">            p0Denom += sum(trainMatrix[i])</div><div class="line">    <span class="comment">#对每个元素做除法</span></div><div class="line">    <span class="comment"># 修改后：对乘积去自然对数，防止因大部分因子非常小导致程序下溢出，最终得到0</span></div><div class="line">    <span class="comment"># f(x)与ln(f(x))在相同区域同时增加或减少，也在相同点上取到极值，因此虽然他们取值不同，但不影响最终结果</span></div><div class="line">    <span class="comment"># ln(a*b)=ln(a)+ln(b)</span></div><div class="line">    p1Vect = log(p1Num/p1Denom) <span class="comment">#修改前p1Num/p1Denom  某个词占总侮辱性词的概率的对数</span></div><div class="line">    p0Vect = log(p0Num/p0Denom) <span class="comment">#修改前p0Num/p0Denom</span></div><div class="line">    <span class="keyword">return</span> p0Vect,p1Vect,pAbusive</div><div class="line"></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">朴素贝叶斯分类函数</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">vec2Classify:待分类的向量</span></div><div class="line"><span class="string">p0Vec, p1Vec, pClass1:使用trainNB0计算得到的3个概率</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">classifyNB</span><span class="params">(vec2Classify, p0Vec, p1Vec, pClass1)</span>:</span></div><div class="line">    <span class="comment">#print vec2Classify</span></div><div class="line">    <span class="comment"># 元素相乘,numpy的数组计算链两个向量相乘，这里的相乘是对应元素相乘</span></div><div class="line">    <span class="comment">#先将两个向量第一个元素相乘，然后将第二个元素相乘 ...</span></div><div class="line">    <span class="comment">#再将词汇表中所有的词对应值相加，再将该值加到类别的对数概率上</span></div><div class="line">    p1 = sum(vec2Classify * p1Vec) + log(pClass1)</div><div class="line">    p0 = sum(vec2Classify * p0Vec) + log(<span class="number">1.0</span>-pClass1)</div><div class="line">    <span class="keyword">if</span> p1 &gt; p0:</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">testingNB</span><span class="params">()</span>:</span></div><div class="line">    listOPosts,listClasses = loadDataSet()</div><div class="line">    myVocabList = createVocabList(listOPosts)</div><div class="line">    trainMat=[]</div><div class="line">    <span class="keyword">for</span> postinDoc <span class="keyword">in</span> listOPosts:</div><div class="line">        trainMat.append(setOfWords2Vec(myVocabList, postinDoc))</div><div class="line">    p0V,p1V,pAb = trainNB0(array(trainMat),array(listClasses))</div><div class="line">    testEntry = [<span class="string">'love'</span>, <span class="string">'my'</span>, <span class="string">'dalmation'</span>]</div><div class="line">    thisDoc = array(setOfWords2Vec(myVocabList, testEntry))</div><div class="line">    <span class="keyword">print</span> testEntry,<span class="string">'Classified as: '</span>,classifyNB(thisDoc,p0V,p1V,pAb)</div><div class="line">    testEntry = [<span class="string">'stupid'</span>,<span class="string">'garbage'</span>]</div><div class="line">    thisDoc = array(setOfWords2Vec(myVocabList, testEntry))</div><div class="line">    <span class="keyword">print</span> testEntry,<span class="string">'Classified as: '</span>,classifyNB(thisDoc,p0V,p1V,pAb)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">测试训练函数</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="comment">#从预先加载值中调入数据</span></div><div class="line">listOPosts,listClasses=loadDataSet()</div><div class="line"><span class="comment">#构建一个包含所有词列表的myVocabList</span></div><div class="line">myVocabList = createVocabList(listOPosts)</div><div class="line"><span class="comment">#print myVocabList</span></div><div class="line"><span class="comment">#使用词向量来填充trainMat列表</span></div><div class="line">trainMat = []</div><div class="line"><span class="keyword">for</span> postinDoc <span class="keyword">in</span> listOPosts:</div><div class="line">    trainMat.append(setOfWords2Vec(myVocabList,postinDoc))</div><div class="line">    <span class="comment">#print postinDoc</span></div><div class="line"><span class="comment">#print trainMat</span></div><div class="line"><span class="comment">#print listClasses</span></div><div class="line"><span class="comment">#给出属于侮辱性文档的概率以及两个类别的概率向量</span></div><div class="line">p0V,p1V,pAb=trainNB0(trainMat,listClasses)</div><div class="line">p0V</div></pre></td></tr></table></figure><pre><code>array([-2.56494936, -2.56494936, -2.56494936, -3.25809654, -3.25809654,       -2.56494936, -2.56494936, -2.56494936, -3.25809654, -2.56494936,       -2.56494936, -2.56494936, -2.56494936, -3.25809654, -3.25809654,       -2.15948425, -3.25809654, -3.25809654, -2.56494936, -3.25809654,       -2.56494936, -2.56494936, -3.25809654, -2.56494936, -2.56494936,       -2.56494936, -3.25809654, -2.56494936, -3.25809654, -2.56494936,       -2.56494936, -1.87180218])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">测试朴素贝叶斯分类器</span></div><div class="line"><span class="string">"""</span></div><div class="line">testingNB()</div></pre></td></tr></table></figure><pre><code>[&apos;love&apos;, &apos;my&apos;, &apos;dalmation&apos;] Classified as:  0[&apos;stupid&apos;, &apos;garbage&apos;] Classified as:  1</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">文本解析</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="keyword">import</span> re</div><div class="line"><span class="comment">#除单词、数字外的任意字符串</span></div><div class="line">regEx = re.compile(<span class="string">'\\W*'</span>)</div><div class="line">mySent = <span class="string">'This book is the best book on Python or M.L. I have ever laid wtes upon.'</span></div><div class="line">listOfTokens = regEx.split(mySent)</div><div class="line"><span class="comment"># 去除空字符串</span></div><div class="line">[tok <span class="keyword">for</span> tok <span class="keyword">in</span> listOfTokens <span class="keyword">if</span> len(tok) &gt; <span class="number">0</span>]</div><div class="line"><span class="comment">#全装成小写</span></div><div class="line">[tok.lower() <span class="keyword">for</span> tok <span class="keyword">in</span> listOfTokens <span class="keyword">if</span> len(tok)] </div><div class="line"><span class="comment">#读取文本文件</span></div><div class="line">emailText = open(<span class="string">'F:\\study\\email\\ham\\6.txt'</span>).read()</div><div class="line">listOfTokens=regEx.split(emailText)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">使用朴素贝叶斯进行交叉验证</span></div><div class="line"><span class="string">文本解析及完整的垃圾邮件测试函数</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">textParse</span><span class="params">(bigString)</span>:</span></div><div class="line">    <span class="keyword">import</span> re</div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    分割从文本在读取的串</span></div><div class="line"><span class="string">    """</span></div><div class="line">    <span class="comment">#拆分</span></div><div class="line">    listOfTokens = re.split(<span class="string">r'\w'</span>, bigString)</div><div class="line">    <span class="comment">#长度&gt;2  全转化成小写</span></div><div class="line">    <span class="keyword">return</span> [tok.lower() <span class="keyword">for</span> tok <span class="keyword">in</span> listOfTokens <span class="keyword">if</span> len(tok) &gt; <span class="number">2</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">spamTest</span><span class="params">()</span>:</span></div><div class="line">    docList = [];classList = [];fullText = []</div><div class="line">    <span class="comment">#导入并解析文件</span></div><div class="line">    <span class="comment">#读取文件，设置类别spam(垃圾邮件) 1 ham 0</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">26</span>):</div><div class="line">        wordList = textParse(open(<span class="string">'F:\\study\\email\\spam\\%d.txt'</span> % i).read())</div><div class="line">        docList.append(wordList)</div><div class="line">        fullText.extend(wordList)</div><div class="line">        classList.append(<span class="number">1</span>)</div><div class="line">        wordList = textParse(open(<span class="string">'F:\\study\\email\\ham\\%d.txt'</span> % i).read())</div><div class="line">        docList.append(wordList)</div><div class="line">        fullText.extend(wordList)</div><div class="line">        classList.append(<span class="number">0</span>)</div><div class="line">    <span class="comment">#创建无重复的词集</span></div><div class="line">    vocabList = createVocabList(docList)</div><div class="line">    trainingSet = range(<span class="number">50</span>);</div><div class="line">    testSet = []</div><div class="line">    <span class="comment">#随机构建训练集</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">        <span class="comment">#random.uniform(x,y)随机生成下一个实数，范围[x,)</span></div><div class="line">        <span class="comment">#是否会重复？（即使每次的len(trainingSet)不一样）</span></div><div class="line">        randIndex = int(random.uniform(<span class="number">0</span>,len(trainingSet)))</div><div class="line">        <span class="comment">#将选取的文档编号添加到测试集</span></div><div class="line">        testSet.append(trainingSet[randIndex])</div><div class="line">        <span class="comment">#并将其从训练集删除</span></div><div class="line">        <span class="keyword">del</span>(trainingSet[randIndex])</div><div class="line">    trainMat = []</div><div class="line">    trainClasses = []</div><div class="line">    <span class="keyword">for</span> docIndex <span class="keyword">in</span> trainingSet:</div><div class="line">        <span class="comment">#创建词集模型，若docList[docIndex]在vocabList中出现，则记1</span></div><div class="line">        <span class="comment">#并将得到的矩阵添加到trainMat</span></div><div class="line">        trainMat.append(setOfWords2Vec(vocabList, docList[docIndex]))</div><div class="line">        <span class="comment">#将对应的分类添加到trainClasses</span></div><div class="line">        trainClasses.append(classList[docIndex])</div><div class="line">    <span class="comment">#调用trainNBO获取到对应的概率向量 pSpam：训练样本中，垃圾邮件占总邮件的概率</span></div><div class="line">    <span class="comment">#trainNB0(trainMat, trainClasses)</span></div><div class="line">    p0V,p1V,pSpam = trainNB0(array(trainMat), array(trainClasses))</div><div class="line">    errorCount = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> docIndex <span class="keyword">in</span> testSet:</div><div class="line">        <span class="comment">#创建测试集</span></div><div class="line">        wordVector = setOfWords2Vec(vocabList, docList[docIndex])</div><div class="line">        <span class="comment">#进行分类，并将分类结果与正式分类结果比较，错误则错误数+1</span></div><div class="line">        <span class="comment">#print classifyNB(array(wordVector), p0V, p1V, pSpam),classList[docIndex]</span></div><div class="line">        <span class="keyword">if</span> classifyNB(array(wordVector), p0V, p1V, pSpam) != classList[docIndex]:</div><div class="line">            errorCount += <span class="number">1</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'the error rate is: '</span>,float(errorCount)/len(testSet)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">使用朴素贝叶斯进行交叉验证，测试垃圾邮件分类器</span></div><div class="line"><span class="string">"""</span></div><div class="line">spamTest();</div></pre></td></tr></table></figure><pre><code>the error rate is:  0.1</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#4.7节 使用朴素贝叶斯分类器从个人广告中获取区域倾向</span></div><div class="line"><span class="comment">#目前在内网环境，暂时先放着</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于概率论的分类方法：朴素贝叶斯。（条件概率）&lt;/p&gt;
&lt;p&gt;朴素贝叶斯：朴素贝叶斯是一种简单但是非常强大的线性分类器。它在垃圾邮件分类，疾病诊断中都取得了很大的成功。它只所以称为朴素，是因为它假设特征之间是相互独立的，但是在现实生活中，这种假设基本上是不成立的。那么即使是在假设不成立的条件下，它依然表现的很好，尤其是在小规模样本的情况下。但是，如果每个特征之间有很强的关联性和非线性的分类问题会导致朴素贝叶斯模型有很差的分类效果。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://JohnneyAnn.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="机器学习" scheme="http://JohnneyAnn.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Python" scheme="http://JohnneyAnn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>机器学习实战（三）决策树</title>
    <link href="http://JohnneyAnn.github.io/2017/09/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%89%EF%BC%89%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <id>http://JohnneyAnn.github.io/2017/09/08/机器学习实战（三）决策树/</id>
    <published>2017-09-08T14:05:57.088Z</published>
    <updated>2017-09-08T14:05:57.088Z</updated>
    
    <content type="html"><![CDATA[<p>决策树是一种简单高效并且具有强解释性的模型，广泛应用于数据分析领域。其本质是一颗由多个判断节点组成的树，在使用模型进行预测时，根据输入参数依次在各个判断节点进行判断游走，最后到叶子节点即为预测结果。<br><a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">文件trees</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log</div><div class="line"><span class="keyword">import</span> operator</div><div class="line">%matplotlib inline <span class="comment">#这一句设置在线显示</span></div><div class="line"></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">创建数据集</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDataSet</span><span class="params">()</span>:</span></div><div class="line">    dataSet = [[<span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</div><div class="line">              [<span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</div><div class="line">              [<span class="number">1</span>, <span class="number">0</span>, <span class="string">'no'</span>],</div><div class="line">              [<span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>],</div><div class="line">              [<span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>]]</div><div class="line">    labels = [<span class="string">'no surfacing'</span>,<span class="string">'flippers'</span>]</div><div class="line">    <span class="keyword">return</span> dataSet, labels</div><div class="line"></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">计算给定数据集的信息熵(香农)</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcuShannonEnt</span><span class="params">(dataSet)</span>:</span></div><div class="line">    numEntries = len(dataSet)</div><div class="line">    labelCounts = &#123;&#125;</div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    为所有可能分能创建字典</span></div><div class="line"><span class="string">    """</span></div><div class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</div><div class="line">        currentLabel = featVec[<span class="number">-1</span>]</div><div class="line">        <span class="comment">#方法1</span></div><div class="line">        <span class="comment">#   if currentLabel not in labelCounts.keys():</span></div><div class="line">        <span class="comment">#        labelCounts[currentLabel] = 0</span></div><div class="line">        <span class="comment">#   labelCounts[currentLabel] += 1</span></div><div class="line">        <span class="comment">#方法2</span></div><div class="line">        labelCounts[currentLabel] = labelCounts.get(currentLabel,<span class="number">0</span>) + <span class="number">1</span></div><div class="line">    shannonEnt = <span class="number">0.0</span></div><div class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> labelCounts:</div><div class="line">        <span class="string">"""</span></div><div class="line"><span class="string">        每个类别所占的比</span></div><div class="line"><span class="string">        """</span></div><div class="line">        prob = float(labelCounts[key])/numEntries</div><div class="line">        <span class="string">"""</span></div><div class="line"><span class="string">        求对数</span></div><div class="line"><span class="string">        """</span></div><div class="line">        shannonEnt -= prob * log(prob,<span class="number">2</span>)</div><div class="line">    <span class="keyword">return</span> shannonEnt</div><div class="line"></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">按照给定特征划分数据集</span></div><div class="line"><span class="string">三个参数：待划分的数据集、划分数据集的特征、特征的返回值</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitDataSet</span><span class="params">(dataSet, axis, value)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    创建新的list对象</span></div><div class="line"><span class="string">    """</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    理解：按axis这列来划分，若这列的数=value归到一类，并创建一个新列表返回</span></div><div class="line"><span class="string">    """</span></div><div class="line">    retDataSet = []</div><div class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</div><div class="line">        <span class="keyword">if</span> featVec[axis] == value:</div><div class="line">            <span class="string">"""</span></div><div class="line"><span class="string">            抽取</span></div><div class="line"><span class="string">            """</span></div><div class="line">            <span class="comment"># 应该是清空列表</span></div><div class="line">            reducedFeatVec = featVec[:axis] </div><div class="line">            <span class="comment"># [0+1:]取下标1之后的，这里是取后两位，将元素塞入reducedFeatVec</span></div><div class="line">            reducedFeatVec.extend(featVec[axis+<span class="number">1</span>:]) </div><div class="line">            <span class="comment">#将reducedFeatVec列表塞入retDataSet</span></div><div class="line">            retDataSet.append(reducedFeatVec)</div><div class="line">    <span class="keyword">return</span> retDataSet</div><div class="line">    </div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    选择最好的数据集划分方式</span></div><div class="line"><span class="string">    此处使用ID3算法，获取信息增益最大的</span></div><div class="line"><span class="string">    """</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">chooseBestFeatureToSplit</span><span class="params">(dataSet)</span>:</span></div><div class="line">    <span class="comment">#dataSet[0]列数</span></div><div class="line">    <span class="comment">#只用前两列进行分类 -1</span></div><div class="line">    numFeatures = len(dataSet[<span class="number">0</span>]) - <span class="number">1</span></div><div class="line">    baseEntropy = calcuShannonEnt(dataSet)</div><div class="line">    <span class="comment">#信息增益</span></div><div class="line">    bestInfoGain = <span class="number">0.0</span></div><div class="line">    bestFeature = <span class="number">-1</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numFeatures):</div><div class="line">        <span class="string">"""</span></div><div class="line"><span class="string">        创建唯一的分类标签列表</span></div><div class="line"><span class="string">        """</span></div><div class="line">        featList = [example[i] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</div><div class="line">        uniqueVals = set(featList)<span class="comment"># 创建集合</span></div><div class="line">        newEntropy = <span class="number">0.0</span></div><div class="line">        <span class="string">"""</span></div><div class="line"><span class="string">        计算每种划分方式的信息熵</span></div><div class="line"><span class="string">        第一列或第二列的划分方式 表3-1 将其他两列分类</span></div><div class="line"><span class="string">        """</span></div><div class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</div><div class="line">            subDataSet = splitDataSet(dataSet, i, value)</div><div class="line">            prob = len(subDataSet)/float(len(dataSet))</div><div class="line">            <span class="string">"""</span></div><div class="line"><span class="string">            将分完的两个类分别计算信息熵，乘以每个分类所出现的概率，相加后得到新的熵</span></div><div class="line"><span class="string">            """</span></div><div class="line">            newEntropy += prob * calcuShannonEnt(subDataSet)</div><div class="line">        <span class="string">"""</span></div><div class="line"><span class="string">        判断信息增益是否大于0</span></div><div class="line"><span class="string">        """</span></div><div class="line">        infoGain = baseEntropy - newEntropy</div><div class="line">        <span class="keyword">if</span>(infoGain &gt; bestInfoGain):</div><div class="line">            <span class="string">"""</span></div><div class="line"><span class="string">            计算最好的信息增益</span></div><div class="line"><span class="string">            """</span></div><div class="line">            bestInfoGain = infoGain</div><div class="line">            <span class="comment">#  i为列数，对应表3-1</span></div><div class="line">            bestFeature = i</div><div class="line">    <span class="keyword">return</span> bestFeature</div><div class="line"></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">类似于投票表决的方法,挑选次数出现最多的类别</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityCnt</span><span class="params">(classList)</span>:</span></div><div class="line">    classCount=&#123;&#125;</div><div class="line">    <span class="keyword">for</span> vote <span class="keyword">in</span> classList:</div><div class="line">        <span class="keyword">if</span> vote <span class="keyword">not</span> <span class="keyword">in</span> classCount.key():</div><div class="line">            classCount[vote] = <span class="number">0</span></div><div class="line">        classCount[vote] += <span class="number">1</span></div><div class="line">    sortedClassCount = sorted(classCount.iteritems(), key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="keyword">True</span>)</div><div class="line">    <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</div><div class="line"></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">创建树的代码</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">createTree</span><span class="params">(dataSet,labels)</span>:</span></div><div class="line">    <span class="comment"># 把dataSet最后一列放到classList</span></div><div class="line">    classList = [example[<span class="number">-1</span>] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</div><div class="line">    <span class="comment">#     print classList</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    类别完全相同则停止继续划分</span></div><div class="line"><span class="string">    """</span></div><div class="line">    <span class="comment">#     对classList第一个元素进行统计，如果与总长度相同，表示只有一个分类</span></div><div class="line">    <span class="keyword">if</span> classList.count(classList[<span class="number">0</span>]) == len(classList):</div><div class="line">        <span class="keyword">return</span> classList[<span class="number">0</span>]</div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    遍历完所有特征时返回出现次数最多的</span></div><div class="line"><span class="string">    """</span></div><div class="line">    <span class="comment">#     只剩最后一项的时候，按较多的</span></div><div class="line">    <span class="comment">#     print dataSet[0]</span></div><div class="line">    <span class="comment">#     计算dataSet第一个元素的长度</span></div><div class="line">    <span class="keyword">if</span> len(dataSet[<span class="number">0</span>]) == <span class="number">1</span>:</div><div class="line">        <span class="keyword">return</span> majorityCnt(classList)</div><div class="line">    <span class="comment">#     获取到最佳特征</span></div><div class="line">    bestFeat = chooseBestFeatureToSplit(dataSet)</div><div class="line">    bestFeatLabel = labels[bestFeat]</div><div class="line">    myTree = &#123;bestFeatLabel:&#123;&#125;&#125;</div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    得到列表包含的所有属性值</span></div><div class="line"><span class="string">    """</span></div><div class="line">    <span class="comment"># 从标签里删除最佳特征标签</span></div><div class="line">    <span class="keyword">del</span>(labels[bestFeat])</div><div class="line">    <span class="comment">#将dataSet每个元素的第一列拿出</span></div><div class="line">    featValues = [example[bestFeat] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</div><div class="line">    <span class="comment">#使用set无重复的存入uniqueVals</span></div><div class="line">    uniqueVals = set(featValues)</div><div class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</div><div class="line">    <span class="comment">#将标签复制一份，保证每次调用函数时不改变原始列表的内容，使用新变量代替原始列表</span></div><div class="line">        subLabels = labels[:]</div><div class="line">        <span class="comment">#splitDataSet按当前分类方式进行分类，并将其他项作为新列表返回</span></div><div class="line">        myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet, bestFeat, value),subLabels)</div><div class="line">    <span class="keyword">return</span> myTree</div><div class="line"></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">使用决策树的分类函数</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">classify</span><span class="params">(inputTree,featLabels,testVec)</span>:</span></div><div class="line">    firstStr = inputTree.keys()[<span class="number">0</span>]</div><div class="line">    secondDict = inputTree[firstStr]</div><div class="line">    <span class="comment">#将标签字符串转换成索引</span></div><div class="line">    featIndex = featLabels.index(firstStr)</div><div class="line"><span class="comment">#     for key in secondDict.keys():</span></div><div class="line"><span class="comment">#         if testVec[featIndex] == key:</span></div><div class="line"><span class="comment">#             classLabel = classify(secondDict[key],featLabels,testVec)</span></div><div class="line"><span class="comment">#         else:</span></div><div class="line"><span class="comment">#             classLabel = secondDict[key]</span></div><div class="line">    <span class="comment">#下面是源码中的内容 可以运行</span></div><div class="line">    key = testVec[featIndex]</div><div class="line">    valueOfFeat = secondDict[key]</div><div class="line">    <span class="keyword">if</span> isinstance(valueOfFeat, dict): </div><div class="line">        <span class="comment"># 非叶子节点继续递归判断</span></div><div class="line">        classLabel = classify(valueOfFeat, featLabels, testVec)</div><div class="line">    <span class="keyword">else</span>: classLabel = valueOfFeat</div><div class="line">    <span class="keyword">return</span> classLabel</div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">决策树的存储，每次调用使用已经构造好的决策树，节省时间</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">使用pickle模块存储决策树</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">storeTree</span><span class="params">(inputTree,filename)</span>:</span></div><div class="line">    <span class="keyword">import</span> pickle</div><div class="line">    fw = open(filename,<span class="string">'w'</span>)</div><div class="line">    <span class="comment">#将对象保存到文件中</span></div><div class="line">    pickle.dump(inputTree,fw)</div><div class="line">    fw.close()</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">grabTree</span><span class="params">(filename)</span>:</span></div><div class="line">    <span class="keyword">import</span> pickle</div><div class="line">    fr = open(filename)</div><div class="line">    <span class="comment">#从文件中读取</span></div><div class="line">    <span class="keyword">return</span> pickle.load(fr)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">测试决策树分类函数</span></div><div class="line"><span class="string">"""</span></div><div class="line">myDat,labels=createDataSet()</div><div class="line">myTree=retrieveTree(<span class="number">0</span>)</div><div class="line">classify(myTree,labels,[<span class="number">1</span>,<span class="number">1</span>])</div></pre></td></tr></table></figure><pre><code>&apos;yes&apos;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">测试存储效果</span></div><div class="line"><span class="string">"""</span></div><div class="line">myTree=retrieveTree(<span class="number">0</span>)</div><div class="line">storeTree(myTree,<span class="string">'classfierStorage.txt'</span>)</div><div class="line">grabTree(<span class="string">'classfierStorage.txt'</span>)</div></pre></td></tr></table></figure><pre><code>{&apos;no surfacing&apos;: {0: &apos;no&apos;, 1: {&apos;flippers&apos;: {0: &apos;no&apos;, 1: &apos;yes&apos;}}}}</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">生成决策树字典</span></div><div class="line"><span class="string">"""</span></div><div class="line">myData,labels = createDataSet()</div><div class="line">myTree = createTree(myData,labels)</div><div class="line">myTree</div></pre></td></tr></table></figure><pre><code>{&apos;no surfacing&apos;: {0: &apos;no&apos;, 1: {&apos;flippers&apos;: {0: &apos;no&apos;, 1: &apos;yes&apos;}}}}</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">测试选择最好的数据集划分方式</span></div><div class="line"><span class="string">"""</span></div><div class="line">myData,labels = createDataSet()</div><div class="line">chooseBestFeatureToSplit(myData)</div></pre></td></tr></table></figure><pre><code>0</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">测试使用创建的数据集计算信息熵</span></div><div class="line"><span class="string">"""</span></div><div class="line">myData,labels = createDataSet()</div><div class="line"><span class="comment">#增加分类熵变大</span></div><div class="line">myData[<span class="number">0</span>][<span class="number">-1</span>]=<span class="string">'maybe'</span></div><div class="line">calcuShannonEnt(myData)</div></pre></td></tr></table></figure><pre><code>1.3709505944546687</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">测试划分数据集</span></div><div class="line"><span class="string">"""</span></div><div class="line">myData,labels = createDataSet()</div><div class="line">splitDataSet(myData,<span class="number">0</span>,<span class="number">1</span>)</div></pre></td></tr></table></figure><pre><code>[[1, &apos;yes&apos;], [1, &apos;yes&apos;], [0, &apos;no&apos;]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">文件treePlotter</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">使用matplot文本注解回执树节点</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">定义文本框和箭头格式</span></div><div class="line"><span class="string">"""</span></div><div class="line">decisionNode = dict(boxstyle=<span class="string">"sawtooth"</span>, fc=<span class="string">"0.8"</span>)</div><div class="line">leafNode = dict(boxstyle=<span class="string">"round4"</span>, fc=<span class="string">"0.8"</span>)</div><div class="line">arrow_args = dict(arrowstyle=<span class="string">"&lt;-"</span>)</div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">绘制带箭头的注解</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotNode</span><span class="params">(nodeTxt, centerPt, parentPt, nodeType)</span>:</span></div><div class="line">    createPlot.ax1.annotate(nodeTxt, xy=parentPt, xycoords=<span class="string">'axes fraction'</span>, \</div><div class="line">                           xytext=centerPt, textcoords=<span class="string">'axes fraction'</span>, \</div><div class="line">                            va=<span class="string">"center"</span>, ha=<span class="string">"center"</span>, bbox=nodeType, arrowprops=arrow_args)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">createPlot1</span><span class="params">()</span>:</span></div><div class="line">    fig = plt.figure(<span class="number">1</span>, facecolor=<span class="string">'white'</span>)</div><div class="line">    fig.clf()</div><div class="line">    createPlot.ax1 = plt.subplot(<span class="number">111</span>, frameon=<span class="keyword">False</span>)</div><div class="line">    <span class="comment">#decisionNode leafNode 是节点类型，不同节点类型样式不一样 包围文字的box不一样</span></div><div class="line">    plotNode(<span class="string">'a decision node'</span>, (<span class="number">0.5</span>, <span class="number">0.1</span>), (<span class="number">0.1</span>, <span class="number">0.5</span>), decisionNode)</div><div class="line">    plotNode(<span class="string">'a leaf node'</span>, (<span class="number">0.8</span>, <span class="number">0.1</span>), (<span class="number">0.3</span>, <span class="number">0.8</span>), leafNode)</div><div class="line">    plt.show()</div><div class="line">    </div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">画一个完整的树，我们需要知道有多少个叶节点（确定x）,树有多少层（确定y）</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="comment">#获取叶节点的数目</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getNumLeafs</span><span class="params">(myTree)</span>:</span></div><div class="line">    numLeafs = <span class="number">0</span></div><div class="line">    <span class="comment">#获取第一个键</span></div><div class="line">    <span class="comment">#树的第一层一定只有一个节点</span></div><div class="line">    firstStr = myTree.keys()[<span class="number">0</span>]</div><div class="line">    <span class="comment">#获取第一个键所对应的值</span></div><div class="line">    secondDict = myTree[firstStr]</div><div class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</div><div class="line">        <span class="comment">#判断节点数据（键的值）类型是否为字典</span></div><div class="line">        <span class="keyword">if</span> type(secondDict[key]).__name__==<span class="string">'dict'</span>:</div><div class="line">            numLeafs += getNumLeafs(secondDict[key])</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            numLeafs += <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> numLeafs</div><div class="line"><span class="comment">#获取树的层数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTreeDepth</span><span class="params">(myTree)</span>:</span></div><div class="line">    maxDepth = <span class="number">0</span></div><div class="line">    firstStr = myTree.keys()[<span class="number">0</span>]</div><div class="line">    secondDict = myTree[firstStr]</div><div class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</div><div class="line">        <span class="keyword">if</span> type(secondDict[key]).__name__==<span class="string">'dict'</span>:</div><div class="line">            thisDepth = <span class="number">1</span> + getTreeDepth(secondDict[key])</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            thisDepth = <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> thisDepth &gt; maxDepth : maxDepth = thisDepth</div><div class="line">    <span class="keyword">return</span> maxDepth</div><div class="line"></div><div class="line"><span class="comment">#预先存储下树的信息，避免每次测试都需要创建树，为了节约练习的时间</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">retrieveTree</span><span class="params">(i)</span>:</span></div><div class="line">    listOfTrees = [&#123;<span class="string">'no surfacing'</span>:</div><div class="line">                    &#123;<span class="number">0</span>:<span class="string">'no'</span>,</div><div class="line">                     <span class="number">1</span>:&#123;<span class="string">'flippers'</span>:</div><div class="line">                        &#123;<span class="number">0</span>:<span class="string">'no'</span>,<span class="number">1</span>:<span class="string">'yes'</span>&#125;&#125;&#125;&#125;,</div><div class="line">                  &#123;<span class="string">'no surfacing'</span>:</div><div class="line">                   &#123;<span class="number">0</span>:<span class="string">'no'</span>,<span class="number">1</span>:&#123;<span class="string">'flippers'</span>:</div><div class="line">                     &#123;<span class="number">0</span>:</div><div class="line">                      &#123;<span class="string">'head'</span>:</div><div class="line">                       &#123;<span class="number">0</span>:<span class="string">'no'</span>,<span class="number">1</span>:<span class="string">'yes'</span>&#125;,<span class="number">1</span>:<span class="string">'no'</span>&#125;&#125;&#125;&#125;&#125;]</div><div class="line">    <span class="keyword">return</span> listOfTrees[i]</div><div class="line"></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">在父子节点间填充文本信息</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotMidText</span><span class="params">(cntrPt, parentPt, txtString)</span>:</span></div><div class="line">    <span class="comment">#计算文本信息的位置</span></div><div class="line">    <span class="comment">#① 0.5 1</span></div><div class="line">    xMid = (parentPt[<span class="number">0</span>] - cntrPt[<span class="number">0</span>])/<span class="number">2.0</span> + cntrPt[<span class="number">0</span>]</div><div class="line">    yMid = (parentPt[<span class="number">1</span>] - cntrPt[<span class="number">1</span>])/<span class="number">2.0</span> + cntrPt[<span class="number">1</span>]</div><div class="line">    createPlot.ax1.text(xMid, yMid, txtString)</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotTree</span><span class="params">(myTree, parentPt, nodeTxt)</span>:</span></div><div class="line">    <span class="comment">#计算宽与高</span></div><div class="line">    numLeafs = getNumLeafs(myTree)</div><div class="line">    depth = getTreeDepth(myTree)</div><div class="line">    <span class="comment">#获取根节点</span></div><div class="line">    firstStr = myTree.keys()[<span class="number">0</span>]</div><div class="line">    cntrPt = (plotTree.xOff + (<span class="number">1.0</span> + float(numLeafs))/<span class="number">2.0</span>/plotTree.totalW, plotTree.yOff)</div><div class="line">    <span class="comment">#① (0.5,1)  (0.5,1)  ""</span></div><div class="line">    <span class="comment"># 在父子节点之间添加文本信息</span></div><div class="line">    plotMidText(cntrPt, parentPt, nodeTxt)</div><div class="line">    <span class="comment">#画节点: 节点内容 子节点坐标  父节点坐标  节点类型</span></div><div class="line">    plotNode(firstStr, cntrPt, parentPt, decisionNode)</div><div class="line">    <span class="comment"># 第二层 </span></div><div class="line">    secondDict = myTree[firstStr]</div><div class="line">    <span class="comment"># 修改y偏移量 1-1/2  有坐标范围0-1 这里从上到下绘制因此依次递减</span></div><div class="line">    plotTree.yOff = plotTree.yOff - <span class="number">1.0</span>/plotTree.totalD</div><div class="line">    <span class="comment"># 判断第二层节点下的节点是否为叶子节点</span></div><div class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</div><div class="line">        <span class="comment">#不是叶子节点  递归执行</span></div><div class="line">        <span class="keyword">if</span> type(secondDict[key]).__name__==<span class="string">'dict'</span>:</div><div class="line">            plotTree(secondDict[key],cntrPt,str(key))</div><div class="line">        <span class="comment">#如果是叶子节点</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="comment">#计算x的偏移量 -1/8+1/4</span></div><div class="line">            plotTree.xOff = plotTree.xOff + <span class="number">1.0</span>/plotTree.totalW</div><div class="line">            plotNode(secondDict[key], (plotTree.xOff,plotTree.yOff), cntrPt, leafNode)</div><div class="line">            plotMidText((plotTree.xOff, plotTree.yOff), cntrPt, str(key))</div><div class="line">    <span class="comment"># 1/2+1/2</span></div><div class="line">    plotTree.yOff = plotTree.yOff + <span class="number">1.0</span>/plotTree.totalD</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">createPlot</span><span class="params">(inTree)</span>:</span></div><div class="line">    <span class="comment">#facecolor设置背景</span></div><div class="line">    fig = plt.figure(<span class="number">1</span>, facecolor=<span class="string">'white'</span>)</div><div class="line">    <span class="comment">#清除</span></div><div class="line">    fig.clf()</div><div class="line">    <span class="comment">#清空ticks，标线，这里应该就是坐标轴</span></div><div class="line">    axprops = dict(xticks=[], yticks=[])</div><div class="line">    <span class="comment">#这个是没有ticks的</span></div><div class="line">    <span class="comment">#createPlot.ax1 = plt.subplot(111,frameon=False, **axprops)</span></div><div class="line">    <span class="comment">#这个是有ticks的</span></div><div class="line">    createPlot.ax1 = plt.subplot(<span class="number">111</span>,frameon=<span class="keyword">False</span>)</div><div class="line">    <span class="comment">#将树的深度和叶子节点数保存为全局变量</span></div><div class="line">    plotTree.totalW = float(getNumLeafs(inTree))</div><div class="line">    <span class="keyword">print</span> <span class="string">"totalW: %f"</span> % plotTree.totalW</div><div class="line">    plotTree.totalD = float(getTreeDepth(inTree))</div><div class="line">    <span class="keyword">print</span> <span class="string">"totalD: %f"</span>% plotTree.totalD</div><div class="line">    <span class="comment"># -0.5/4</span></div><div class="line">    plotTree.xOff = <span class="number">-0.5</span>/plotTree.totalW;</div><div class="line">    plotTree.yOff = <span class="number">1.0</span></div><div class="line">    <span class="comment">#设置跟节点坐标</span></div><div class="line">    plotTree(inTree, (<span class="number">0.5</span>,<span class="number">1.0</span>), <span class="string">''</span>)</div><div class="line">    plt.show()</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">测试获取树的叶子节点数，树的层数</span></div><div class="line"><span class="string">"""</span></div><div class="line">myTree = retrieveTree(<span class="number">0</span>)</div><div class="line">getNumLeafs(myTree)</div><div class="line">getTreeDepth(myTree)</div></pre></td></tr></table></figure><pre><code>2</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">创建树节点</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">前面的createPlot()为了做区分 改名为createPlot1</span></div><div class="line"><span class="string">"""</span></div><div class="line">createPlot1()</div></pre></td></tr></table></figure><p><img src="/img/tree/output_9_0.png" alt="图像输出"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">获取树信息</span></div><div class="line"><span class="string">"""</span></div><div class="line">myTree=retrieveTree(<span class="number">0</span>)</div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">创建树</span></div><div class="line"><span class="string">"""</span></div><div class="line">createPlot(myTree)</div></pre></td></tr></table></figure><pre><code>totalW: 3.000000totalD: 2.000000</code></pre><p><img src="/img/tree/output_10_1.png" alt="图像输出"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">添加节点，测试输出效果</span></div><div class="line"><span class="string">"""</span></div><div class="line">myTree=retrieveTree(<span class="number">0</span>)</div><div class="line">myTree[<span class="string">'no surfacing'</span>][<span class="number">3</span>]=<span class="string">'maybe'</span></div><div class="line">createPlot(myTree)</div></pre></td></tr></table></figure><p><img src="/img/tree/output_11_0.png" alt="图像输出"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fr=open(<span class="string">'F:\study\lenses.txt'</span>)</div><div class="line">lences=[inst.strip().split(<span class="string">'\t'</span>) <span class="keyword">for</span> inst <span class="keyword">in</span> fr.readlines()]</div><div class="line">lensesLabels=[<span class="string">'age'</span>,<span class="string">'preascript'</span>,<span class="string">'astigmatic'</span>,<span class="string">'tearRate'</span>]</div><div class="line">lensesTree = createTree(lences,lensesLabels)</div><div class="line">lensesTree</div></pre></td></tr></table></figure><pre><code>{&apos;tearRate&apos;: {&apos;normal&apos;: {&apos;astigmatic&apos;: {&apos;no&apos;: {&apos;age&apos;: {&apos;pre&apos;: &apos;soft&apos;,      &apos;presbyopic&apos;: {&apos;preascript&apos;: {&apos;hyper&apos;: &apos;soft&apos;, &apos;myope&apos;: &apos;no lenses&apos;}},      &apos;young&apos;: &apos;soft&apos;}},    &apos;yes&apos;: {&apos;preascript&apos;: {&apos;hyper&apos;: {&apos;age&apos;: {&apos;pre&apos;: &apos;no lenses&apos;,        &apos;presbyopic&apos;: &apos;no lenses&apos;,        &apos;young&apos;: &apos;hard&apos;}},      &apos;myope&apos;: &apos;hard&apos;}}}},  &apos;reduced&apos;: &apos;no lenses&apos;}}</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">createPlot(lensesTree)</div></pre></td></tr></table></figure><p><img src="/img/tree/output_13_0.png" alt="图像输出"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;决策树是一种简单高效并且具有强解释性的模型，广泛应用于数据分析领域。其本质是一颗由多个判断节点组成的树，在使用模型进行预测时，根据输入参数依次在各个判断节点进行判断游走，最后到叶子节点即为预测结果。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://JohnneyAnn.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="机器学习" scheme="http://JohnneyAnn.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Python" scheme="http://JohnneyAnn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>机器学习实战（二）k-近邻算法</title>
    <link href="http://JohnneyAnn.github.io/2017/09/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98%EF%BC%88%E4%BA%8C%EF%BC%89k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/"/>
    <id>http://JohnneyAnn.github.io/2017/09/08/机器学习实战（二）k-近邻算法/</id>
    <published>2017-09-08T14:00:43.795Z</published>
    <updated>2017-09-08T14:00:43.787Z</updated>
    
    <content type="html"><![CDATA[<p>k-近邻算法：KNN是通过测量不同特征值之间的距离进行分类。它的的思路是：如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。K通常是不大于20的整数。KNN算法中，所选择的邻居都是已经正确分类的对象。该方法在定类决策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别。<br><a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</div><div class="line"><span class="keyword">import</span> operator</div><div class="line"><span class="comment"># 它可以列出给定目录下的文件名</span></div><div class="line"><span class="keyword">from</span> os <span class="keyword">import</span> listdir</div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">科学计算包Numpy</span></div><div class="line"><span class="string">运算符模块operator</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDataSet</span><span class="params">()</span>:</span></div><div class="line">    group = array([[<span class="number">1.0</span>,<span class="number">1.1</span>],[<span class="number">1.0</span>,<span class="number">1.0</span>],[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0.1</span>]])</div><div class="line">    labels = [<span class="string">'A'</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'B'</span>]</div><div class="line">    <span class="keyword">return</span> group,labels</div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">读取文件并转成矩阵</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">file2matrix</span><span class="params">(filename)</span>:</span></div><div class="line">    fr = open(filename)</div><div class="line">    arrayOLines = fr.readlines()</div><div class="line"><span class="comment">#     得到文件行数</span></div><div class="line">    numberOfLines = len(arrayOLines)</div><div class="line">    returnMat = zeros((numberOfLines,<span class="number">3</span>))</div><div class="line"><span class="comment">#     创建返回的NumPy矩阵</span></div><div class="line">    classLabelVector = []</div><div class="line">    index = <span class="number">0</span></div><div class="line"><span class="comment">#     解析文件数据到列表</span></div><div class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> arrayOLines:</div><div class="line"><span class="comment">#     移除字符串头尾指定的字符，默认为空格</span></div><div class="line">        line = line.strip()</div><div class="line">        listFromLine = line.split(<span class="string">'\t'</span>)</div><div class="line">        returnMat[index,:] = listFromLine[<span class="number">0</span>:<span class="number">3</span>]</div><div class="line">        classLabelVector.append(int(listFromLine[<span class="number">-1</span>]))</div><div class="line">        index += <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> returnMat,classLabelVector</div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">归一化特征值</span></div><div class="line"><span class="string">"""</span>    </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">autoNorm</span><span class="params">(dataSet)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    公式</span></div><div class="line"><span class="string">    newValue = (oldValue-min )/(max-min)</span></div><div class="line"><span class="string">    """</span></div><div class="line"><span class="comment">#     从列中选取最小值</span></div><div class="line">    minVals = dataSet.min(<span class="number">0</span>)</div><div class="line">    maxVals = dataSet.max(<span class="number">0</span>)</div><div class="line">    ranges = maxVals - minVals</div><div class="line">    normDataSet = zeros(shape(dataSet))</div><div class="line">    m = dataSet.shape[<span class="number">0</span>]</div><div class="line">    normDataSet = dataSet - tile(minVals, (m,<span class="number">1</span>))</div><div class="line"><span class="comment">#     特征值相除</span></div><div class="line">    normDataSet = normDataSet/tile(ranges, (m,<span class="number">1</span>))</div><div class="line">    <span class="keyword">return</span> normDataSet, ranges, minVals</div><div class="line"></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">分类器测试代码</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">datingClassTest</span><span class="params">()</span>:</span></div><div class="line">    hoRatio = <span class="number">0.10</span></div><div class="line">    datingDataMat,datingLabels = file2matrix(<span class="string">'F:\study\datingTestSet2.txt'</span>)</div><div class="line">    normMat, ranges, minVals = autoNorm(datingDataMat)</div><div class="line">    m = normMat.shape[<span class="number">0</span>]</div><div class="line">    numTestVecs = int(m*hoRatio)</div><div class="line">    errorCount = <span class="number">0.0</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numTestVecs):</div><div class="line">        classifierResult = classify0(normMat[i,:],normMat[numTestVecs:m,:],datingLabels[numTestVecs:m],<span class="number">3</span>)</div><div class="line">        <span class="keyword">print</span> <span class="string">"the classifier came back with: %d, the real answer is: %d"</span> % (classifierResult, datingLabels[i])</div><div class="line">        <span class="keyword">if</span> (classifierResult != datingLabels[i]):errorCount += <span class="number">1.0</span></div><div class="line">    <span class="keyword">print</span> <span class="string">"the total error rate is %f"</span> % (errorCount/float(numTestVecs))</div><div class="line">    </div><div class="line">    </div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">预测函数</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">classifyPerson</span><span class="params">()</span>:</span></div><div class="line">    resultList = [<span class="string">'not at all'</span>,<span class="string">'in small doses'</span>, <span class="string">'in large doses'</span>]</div><div class="line">    percentTats = float(raw_input(<span class="string">"percentage of time spent playing video games?"</span>))</div><div class="line">    ffMiles = float(raw_input(<span class="string">"frequent flier miles earned per year?"</span>))</div><div class="line">    iceCream = float(raw_input(<span class="string">"liter of ice cream consumed per year?"</span>))</div><div class="line">    datingDataMat,datingLabels = file2matrix(<span class="string">'F:\study\datingTestSet2.txt'</span>)</div><div class="line">    norMat, ranges, minVals = autoNorm(datingDataMat)</div><div class="line">    inArr = array ([ffMiles, percentTats, iceCream])</div><div class="line">    classifierResult = classify0((inArr-minVals)/ranges,normMat,datingLabels,<span class="number">3</span>)</div><div class="line">    <span class="keyword">print</span> <span class="string">"You will probably like this person: "</span>,resultList[classifierResult - <span class="number">1</span>]</div><div class="line">    </div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">把32x32的二进制图像矩阵转换为1x1024的向量</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">img2vector</span><span class="params">(filename)</span>:</span></div><div class="line">    returnVect = zeros((<span class="number">1</span>,<span class="number">1024</span>))</div><div class="line">    fr = open(filename)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</div><div class="line">        lineStr = fr.readline()</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">32</span>):</div><div class="line">            returnVect[<span class="number">0</span>,<span class="number">32</span>*i+j] = int(lineStr[j])</div><div class="line">    <span class="keyword">return</span> returnVect</div><div class="line"></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">手写数字识别系统的测试代码</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handwritingClassTest</span><span class="params">()</span>:</span></div><div class="line">    hwLabels = []</div><div class="line"><span class="comment">#     获取目录内容</span></div><div class="line">    trainingFileList = listdir(<span class="string">'F:\\study\\trainingDigits'</span>)</div><div class="line">    m = len(trainingFileList)</div><div class="line"><span class="comment">#     创建m行1024列的矩阵</span></div><div class="line">    trainingMat = zeros((m,<span class="number">1024</span>))</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</div><div class="line">        fileNameStr = trainingFileList[i]</div><div class="line"><span class="comment">#         从文件名解析分类数字，文件名的第一个数</span></div><div class="line"><span class="comment">#         去掉后缀</span></div><div class="line">        fileStr = fileNameStr.split(<span class="string">'.'</span>)[<span class="number">0</span>]</div><div class="line"><span class="comment">#         获取第一个值</span></div><div class="line">        classNumStr = int(fileStr.split(<span class="string">'_'</span>)[<span class="number">0</span>])</div><div class="line">        hwLabels.append(classNumStr)</div><div class="line">        trainingMat[i,:] = img2vector(<span class="string">'F:\\study\\trainingDigits\\%s'</span> % fileNameStr)</div><div class="line">    testFileList = listdir(<span class="string">'F:\\study\\testDigits'</span>)</div><div class="line">    errorCount = <span class="number">0.0</span></div><div class="line">    mTest = len(testFileList)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(mTest):</div><div class="line">        fileNameStr = testFileList[i]</div><div class="line">        fileStr = fileNameStr.split(<span class="string">'.'</span>)[<span class="number">0</span>]</div><div class="line">        classNumStr = int(fileStr.split(<span class="string">'_'</span>)[<span class="number">0</span>])</div><div class="line">        vectorUnderTest = img2vector(<span class="string">'F:\\study\\testDigits\\%s'</span> % fileNameStr)</div><div class="line">        classifierResult = classify0(vectorUnderTest, trainingMat, hwLabels, <span class="number">3</span>)</div><div class="line">        <span class="keyword">print</span> <span class="string">"the classifier came back with: %d, the real answer is : %d"</span> % (classifierResult, classNumStr)</div><div class="line">        </div><div class="line">        <span class="keyword">if</span>(classifierResult != classNumStr) : errorCount +=<span class="number">1.0</span></div><div class="line">    <span class="keyword">print</span> <span class="string">"\nthe total number of errors is : %d"</span> % errorCount</div><div class="line">    <span class="keyword">print</span> <span class="string">"\nthe total error rate is: %f"</span> % (errorCount/float(mTest))</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">group, labels = createDataSet()</div><div class="line"><span class="comment"># print group,labels</span></div></pre></td></tr></table></figure><pre><code>[[ 1.   1.1] [ 1.   1. ] [ 0.   0. ] [ 0.   0.1]] [&apos;A&apos;, &apos;A&apos;, &apos;B&apos;, &apos;B&apos;]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">classify0</span><span class="params">(inX, dataSet, labels, k)</span>:</span></div><div class="line">    <span class="comment"># 计算矩阵行数,一维长度</span></div><div class="line">    dataSetSize = dataSet.shape[<span class="number">0</span>]</div><div class="line">    <span class="comment"># print dataSetSize</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    距离计算:欧式距离公式</span></div><div class="line"><span class="string">    """</span></div><div class="line">    </div><div class="line"><span class="comment">#     tile():重复某个数组tile(A,n)，将数组A重复n次，构成一个新的数组</span></div><div class="line"><span class="comment">#         下面的代码是将inX重复成dataSetSize行，1列的数据</span></div><div class="line"><span class="comment">#         [[0,0],[0,0],[0,0],[0,0]]-[[1.0,1.1],[1.0,1.0],[0,0],[0,0.1]]</span></div><div class="line"><span class="comment">#         = [[-1,-1.1],[-1,-1],[0,0],[0,-0.1]]</span></div><div class="line"><span class="comment">#     下面的步骤就是先计算平方差，再相加后求根号，就是求距离</span></div><div class="line">    diffMat = tile(inX, (dataSetSize,<span class="number">1</span>)) - dataSet</div><div class="line"><span class="comment">#     平方运算</span></div><div class="line">    sqDiffMat = diffMat**<span class="number">2</span></div><div class="line"><span class="comment">#     将向量的每一行相加</span></div><div class="line">    sqDistances = sqDiffMat.sum(axis=<span class="number">1</span>)</div><div class="line"><span class="comment">#     对数组中的每一个元素开根号</span></div><div class="line">    distances = sqDistances**<span class="number">0.5</span></div><div class="line"><span class="comment">#     对数组进行升序排序，返回的是下标不是值！</span></div><div class="line">    sortedDistIndicies = distances.argsort()</div><div class="line">    classCount=&#123;&#125;</div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    选择距离最小的k个点</span></div><div class="line"><span class="string">    """</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k) : </div><div class="line">        voteIlabel = labels[sortedDistIndicies[i]]</div><div class="line"><span class="comment">#         get返回字典中指定键的值，若不存在则返回默认值，这里设置的是0</span></div><div class="line"><span class="comment">#         这里就是给字典中指定键的值加1统计数量,最终是A和B的数量</span></div><div class="line">        classCount[voteIlabel] = classCount.get(voteIlabel, <span class="number">0</span>) + <span class="number">1</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    排序</span></div><div class="line"><span class="string">    """</span></div><div class="line"><span class="comment">#     sorted(data,cmp=None,key=None,reverse=False)</span></div><div class="line"><span class="comment">#         data:待排序数组</span></div><div class="line"><span class="comment">#         cmp :带两个参数的比较函数</span></div><div class="line"><span class="comment">#         key :是带一个参数的函数</span></div><div class="line"><span class="comment">#         reverse:排序规则，True降序</span></div><div class="line"><span class="comment">#         获取对象第一个域的值</span></div><div class="line">    sortedClassCount = sorted(classCount.iteritems(),</div><div class="line">                              key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="keyword">True</span>)</div><div class="line"><span class="comment">#     取第一个则为最大值，也就是当前inX的分类</span></div><div class="line">    <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">classify0([<span class="number">0</span>,<span class="number">0</span>],group,labels,<span class="number">3</span>)</div></pre></td></tr></table></figure><pre><code>&apos;B&apos;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">读取文件数据</span></div><div class="line"><span class="string">"""</span></div><div class="line">datingDataMat,datingLabels = file2matrix(<span class="string">'F:\study\datingTestSet2.txt'</span>)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">执行可视化</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="keyword">import</span> matplotlib</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">可视化</span></div><div class="line"><span class="string">"""</span></div><div class="line">fig = plt.figure()</div><div class="line">ax = fig.add_subplot(<span class="number">111</span>)</div><div class="line">ax.scatter(datingDataMat[:,<span class="number">1</span>], datingDataMat[:,<span class="number">2</span>],<span class="number">15.0</span>*array(datingLabels),<span class="number">15.0</span>*array(datingLabels))</div><div class="line">plt.show()</div></pre></td></tr></table></figure><p><img src="/img/kNN/output_5_0.png" alt="图像输出"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">执行归一化结果</span></div><div class="line"><span class="string">"""</span></div><div class="line">normMat, ranges, minVales = autoNorm(datingDataMat)</div><div class="line"><span class="comment">#normMat</span></div><div class="line"><span class="comment">#ranges</span></div><div class="line"><span class="comment">#minVales</span></div></pre></td></tr></table></figure><pre><code>[  9.12730000e+04   2.09193490e+01   1.69436100e+00]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">执行分类器测试程序</span></div><div class="line"><span class="string">"""</span></div><div class="line">datingClassTest()</div></pre></td></tr></table></figure><pre><code>&apos;\n\xe6\x89\xa7\xe8\xa1\x8c\xe5\x88\x86\xe7\xb1\xbb\xe5\x99\xa8\xe6\xb5\x8b\xe8\xaf\x95\xe7\xa8\x8b\xe5\xba\x8f\n&apos;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">预测当前人员在哪个分类，执行预测函数</span></div><div class="line"><span class="string">"""</span></div><div class="line">classifyPerson()</div></pre></td></tr></table></figure><pre><code>percentage of time spent playing video games?56frequent flier miles earned per year?1654liter of ice cream consumed per year?0.65[  9.12730000e+04   2.09193490e+01   1.69436100e+00]You will probably like this person:  in large doses</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">读取图像</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="comment"># 用\进行转义，否则访问不到</span></div><div class="line">testVector = img2vector(<span class="string">'F:\\study\\trainingDigits\\0_9.txt'</span>)</div><div class="line">testVector[<span class="number">0</span>,<span class="number">0</span>:<span class="number">31</span>]</div></pre></td></tr></table></figure><pre><code>array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,        0.,  0.,  0.,  0.,  1.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,        0.,  0.,  0.,  0.,  0.])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">手写数字识别测试执行</span></div><div class="line"><span class="string">"""</span></div><div class="line">handwritingClassTest()</div></pre></td></tr></table></figure><pre><code>the classifier came back with: 0, the real answer is : 0...    the classifier came back with: 0, the real answer is : 0the classifier came back with: 0, the real answer is : 0the classifier came back with: 1, the real answer is : 1the classifier came back with: 1, the real answer is : 1the classifier came back with: 2, the real answer is : 2the classifier came back with: 2, the real answer is : 2...    the classifier came back with: 2, the real answer is : 2the classifier came back with: 3, the real answer is : 3the classifier came back with: 3, the real answer is : 3the classifier came back with: 9, the real answer is : 3...    the classifier came back with: 3, the real answer is : 3the classifier came back with: 3, the real answer is : 3the classifier came back with: 4, the real answer is : 4the classifier came back with: 4, the real answer is : 4the classifier came back with: 5, the real answer is : 5the classifier came back with: 5, the real answer is : 5the classifier came back with: 5, the real answer is : 5the classifier came back with: 6, the real answer is : 6the classifier came back with: 7, the real answer is : 7the classifier came back with: 6, the real answer is : 8the classifier came back with: 8, the real answer is : 8the classifier came back with: 9, the real answer is : 9the classifier came back with: 9, the real answer is : 9the total number of errors is : 11the total error rate is: 0.011628</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;k-近邻算法：KNN是通过测量不同特征值之间的距离进行分类。它的的思路是：如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。K通常是不大于20的整数。KNN算法中，所选择的邻居都是已经正确分类的对象。该方法在定类决策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://JohnneyAnn.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="机器学习" scheme="http://JohnneyAnn.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Python" scheme="http://JohnneyAnn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>机器学习实战（一）NumPy函数库基础</title>
    <link href="http://JohnneyAnn.github.io/2017/09/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89NumPy%E5%87%BD%E6%95%B0%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    <id>http://JohnneyAnn.github.io/2017/09/08/机器学习实战（一）NumPy函数库基础/</id>
    <published>2017-09-08T13:49:07.298Z</published>
    <updated>2017-09-08T13:49:07.278Z</updated>
    
    <content type="html"><![CDATA[<p>NumPy函数库基础。</p><p>机器学习实战这本书的第一章，下面是这章的代码，添加了些本人的注释，欢迎指正。<br><a id="more"></a></p><h2 id="In"><a href="#In" class="headerlink" title="In"></a>In</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</div><div class="line">random.rand(<span class="number">4</span>,<span class="number">4</span>)</div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">mat()函数将数组转化为矩阵</span></div><div class="line"><span class="string">"""</span></div><div class="line">randMat = mat(random.rand(<span class="number">4</span>,<span class="number">4</span>))</div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">.I操作实现矩阵求逆运算</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="comment"># randMat.I</span></div><div class="line">invRandMat = randMat.I</div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">执行矩阵乘法，矩阵与逆矩阵相乘</span></div><div class="line"><span class="string">"""</span></div><div class="line">randMat*invRandMat</div><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">有误差，得到误差值</span></div><div class="line"><span class="string">"""</span></div><div class="line">myEye = randMat*invRandMat</div><div class="line">myEye - eye(<span class="number">4</span>)</div></pre></td></tr></table></figure><h2 id="OUT"><a href="#OUT" class="headerlink" title="OUT"></a>OUT</h2><pre><code>matrix([[  0.00000000e+00,   2.26241858e-17,  -6.05935799e-17,           1.76115404e-16],        [ -2.15279060e-17,   2.22044605e-16,  -1.18162824e-16,           1.35743489e-16],        [  9.99619619e-19,  -1.22685988e-17,  -2.22044605e-16,           9.91247488e-17],        [  1.00142668e-16,   1.50352035e-17,  -3.19207407e-16,           0.00000000e+00]])</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NumPy函数库基础。&lt;/p&gt;
&lt;p&gt;机器学习实战这本书的第一章，下面是这章的代码，添加了些本人的注释，欢迎指正。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://JohnneyAnn.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="机器学习" scheme="http://JohnneyAnn.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Python" scheme="http://JohnneyAnn.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>认知失调理论</title>
    <link href="http://JohnneyAnn.github.io/2017/09/08/%E8%AE%A4%E7%9F%A5%E5%A4%B1%E8%B0%83%E7%90%86%E8%AE%BA/"/>
    <id>http://JohnneyAnn.github.io/2017/09/08/认知失调理论/</id>
    <published>2017-09-08T13:06:20.977Z</published>
    <updated>2017-09-08T13:06:20.965Z</updated>
    
    <content type="html"><![CDATA[<p>当我们做了某个重要的决定的时候，如果这个决定会让我们失去某些东西，我们就会产生失调。</p><a id="more"></a><p style="text-indent:2em">你应该注意到当一个人做出了一个重要的决定，并在该决定上作出了投资（时间、精力、牺牲和承诺等方面的）之后，会导致他对这些行为以及投资进行合理化的强烈需要。他放弃的越多，努力的越多，像说服自己相信自己的观点是正确的需要就越强烈。</p><p style="text-indent:2em">就是为自己做的重要决定寻找有利的借口，这样才能不产生让自己无法忍受的认知失调。</p><p style="text-indent:2em">另外，这部分还有自我肯定。</p><p style="text-indent:2em">当你做了一件事之后，可能你知道这件事做的并不合理，你将陷入失调，你可能会自责，也可能会觉得虽然做了这件愚蠢的事但我其他事做的还不错或者说这件事带来的并不只是负面效应，实现自我肯定，好让自己从失调中走出来，维护自己的正面形象，让自己好受点。</p><p style="text-indent:2em">这些都是自发发生的，人类有这样的需求。</p><p style="text-indent:2em">也有一些情况，我们为了从错误中学习，我们需要长时间的忍受失调，以仔细且不带个人情感地检查客观情况，这样我们才能够有机会跳出自我合理化和更过分的行为所组成的恶性循环。</p><p style="text-indent:2em">这说明，在某些不太严重的行为上你可以自我肯定，但当行为已经恶性到一定程度，请一定要从错误中学习，这个度自己把握。</p><p style="text-indent:2em">这些都是自发发生的，人类有这样的需求。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们做了某个重要的决定的时候，如果这个决定会让我们失去某些东西，我们就会产生失调。&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://JohnneyAnn.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://JohnneyAnn.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="心理学" scheme="http://JohnneyAnn.github.io/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>就很难受</title>
    <link href="http://JohnneyAnn.github.io/2017/09/08/%E5%B0%B1%E5%BE%88%E9%9A%BE%E5%8F%97/"/>
    <id>http://JohnneyAnn.github.io/2017/09/08/就很难受/</id>
    <published>2017-09-08T13:05:04.811Z</published>
    <updated>2017-09-08T13:05:04.803Z</updated>
    
    <content type="html"><![CDATA[<p>2017.8.11 00.00</p><p>人终究是人吧，哪能格外的理性，感性说话的时候真没你理想插嘴的份。</p><a id="more"></a><p>我想让自己过的好一点，我能感受到我如此的不幸。</p><p>我也想让自己就这样荒芜，却始终无法让自己静下心来。</p><p>我又一次感受到我的苍老。</p><p>心情是糟的，总得需要地方发泄，也尝试过向朋友诉苦，可最终想想因为是朋友，所以我不该让你分享我的悲伤，于是我装作若无其事，闷在心里，有些话写在这里。</p><p>创建博客的初衷也只是为了我自己，我需要地方发泄，也想把现在的一些事记下来，以后还能翻翻看看，至少，回忆还在。当然我也知道，现在去存这些回忆对我并不好，但在以后，我相信还会觉得这是美好。</p><p>博客就这样放着，若真的能看到的话，也算是有缘。至少我会觉得我真的发泄出去了。</p><p>人之所以感受到悲伤，是因为落差，我对那一刻期待的太久了，我能够想到的种种美好都在我们身上。</p><p>如今，你却走了。</p><p>有一次，我梦见我们亲密无间。</p><p>醒来时，才发现我们竟是陌生人。</p><p>God says to man, I heal you therefore I hurt, love you therefore punish.</p><p>晚安。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017.8.11 00.00&lt;/p&gt;
&lt;p&gt;人终究是人吧，哪能格外的理性，感性说话的时候真没你理想插嘴的份。&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://JohnneyAnn.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://JohnneyAnn.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>回合肥路上发生的事</title>
    <link href="http://JohnneyAnn.github.io/2017/09/08/WhatHappenedOnTheRoadOfHeifei/"/>
    <id>http://JohnneyAnn.github.io/2017/09/08/WhatHappenedOnTheRoadOfHeifei/</id>
    <published>2017-09-08T13:04:52.475Z</published>
    <updated>2017-09-08T13:04:52.467Z</updated>
    
    <content type="html"><![CDATA[<p>2017.7.29 周六，加班回来，突然决定回一趟合肥。</p><p>我喜欢坐车来看更多的人。</p><p>也发生了些有趣的事。</p><a id="more"></a><h2 id="事情经过"><a href="#事情经过" class="headerlink" title="事情经过"></a>事情经过</h2><blockquote><p>这是真的，我不是段子手。</p></blockquote><p style="text-indent:2em">行程：南京南-合肥南 19：27</p><br><p style="text-indent:2em">跟往常一样，找到自己的座位坐下，一个小时的车程也想做点什么，那就看书吧，好让自己看起来“安静优雅”（其实内心放荡不羁，这也是印象管理），于是拿出了我的《社会心理学》。</p><br><p style="text-indent:2em">这次的座位是一个三连坐，旁边是两个女生，她们爬在桌子上睡觉，因为看不见脸，自然多了些遐想的空间，于是暗自窃喜。</p><br><p style="text-indent:2em">之后，车开动了，她们也抬起了头开始了聊天，虽然内心已按捺不住希望去看看相貌究竟如何，可奈何我如此害羞！继续埋头看书！</p><br><p style="text-indent:2em">看书自然不专心，她们的聊天我都能听见，于是到了这个故事最关键的地方。</p><br><p style="text-indent:2em">中间位置的女生（以下简称A）对靠窗户女生（以下简称B）说：感谢上苍，给了一副还不错的容貌，吧啦吧啦~~</p><br><p style="text-indent:2em">我就想问一句，话都说到这份上了你能忍住？！当然要一看究竟！我缓缓的抬起头，眼神中透漏出一丝丝的腼腆朝中间位置看去，心中的幻想破灭，渴望去告诉她：你感谢的上苍对你并不好！别傻了！</p><br><p style="text-indent:2em">幻想破灭自然该干啥就干啥，注定旅途是孤独的，只怪我定力不足多看了那一眼。这事并没有完，这种落差导致我仍然没有安心看书，还能够听见他们的聊天。B貌似发起了反攻，对A说，“我妈特别漂亮，之前同学都说我跟我妈一个模子刻出来的”。听见这，心中多了些许的慰藉，B毫不吝啬的夸赞她的母亲让我感到欣赏。BUT! 好景不长，只见画风一转，“但是我妈也有很多不好看的地方，所以这部分我遗传了我爸的。” A附和道：“长得好”。</p><br><p style="text-indent:2em">What ？？？</p><br><p style="text-indent:2em">总结一下，整个聊天过程提炼出四个字，自夸互夸。</p><br><p style="text-indent:2em">我以为只有我不要脸，才会把脸借给吴彦祖。</p><br><p style="text-indent:2em">后来，我把这件事发到了朋友圈，很多人都觉得这事很搞笑，但是，这真的不是段子。其实这种事我们经常能遇见，有个好友评论说：上苍对每个人都是公平的，起码给了她自信。很幽默，也很有道理，没有一个人是完美的，但每个人都有发光点，我们尽力去掩藏自己的不完美的地方来让别人以自己期待的方式看待自己。社会是人的社会，人不完美，所以社会不完美，但同样你抱怨的社会除了给了你所认为的苦难也给你不同于他人的东西，美好的，独特的。</p><h2 id="渴望看透事情的本质"><a href="#渴望看透事情的本质" class="headerlink" title="渴望看透事情的本质"></a>渴望看透事情的本质</h2><p style="text-indent:2em">几乎人人都有自恋的表现，只是程度不同，那么，人为什么会有这种行为呢？</p><br><p style="text-indent:2em">看了看手中的社会心理学，决定找出个答案。</p><br><p style="text-indent:2em">人类的行为最有利的决定因素之一源于我们希望维护一个稳定、正面的自我形象的需求，换言之，我们希望保持一个对自己相对有利的看法，特别是当有证据与我们美好的自我形象相抵触时。</p><br><p style="text-indent:2em">过度自恋也可以用这样的方式来解释，她在掩饰，渴望得到认同，而她谈话的对象正好在使用“印象管理”中一个比较常见的策略—–逢迎。逢迎就是我们常说的奉承，不光用于下属对上司的怕马屁，也用于交流的双方为了获得他人的好感而采取的符合他人意图的举动。当逢迎取得成效的时候，那被逢迎的对方应该也是同样的人，才出现了这次故事中的自夸互夸。臭味相投自然人以群分。说的这些没有任何贬低的意思，这种行为所有人都有过，这里只是给一个解释希望对我们的自我认知有一定的帮助，当我们能够清除的认识自己的行为时自然能够更理性的对待其他的事。最后说一下，这个行为下的自信、乐观照样值得欣赏。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017.7.29 周六，加班回来，突然决定回一趟合肥。&lt;/p&gt;
&lt;p&gt;我喜欢坐车来看更多的人。&lt;/p&gt;
&lt;p&gt;也发生了些有趣的事。&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://JohnneyAnn.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="记录" scheme="http://JohnneyAnn.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
      <category term="随笔" scheme="http://JohnneyAnn.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="心理学" scheme="http://JohnneyAnn.github.io/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>情绪的二因素理论</title>
    <link href="http://JohnneyAnn.github.io/2017/09/08/Two-factorTheoryOfEmotion/"/>
    <id>http://JohnneyAnn.github.io/2017/09/08/Two-factorTheoryOfEmotion/</id>
    <published>2017-09-08T13:04:38.147Z</published>
    <updated>2017-09-08T13:04:38.139Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>当情感说话时，理智很少不听从。         ——Milan Kundera</p></blockquote><a id="more"></a><p style="text-indent:2em">情绪的二因素理论是社会心理学自我认知部分的内容。该理论主张情绪经验是一种两个阶段的自我知觉过程，首先，我们必须体验到生理的激发，接着，再为这个激发状态寻找适当的解释。</p><p style="text-indent:2em">这个解释就是为我们所处的激发状态做归因，比如说，你和你女票分手了，体验到生理上的刺激唤起你的悲伤情绪，然后你开始做归因，你的难受是否是因为分手这件事导致的，因为我们每天身边发生了各种各样的事，当前的状态可能由多件事交叉刺激，那么你做出怎样的归因就决定了你后来有什么感受。</p><p style="text-indent:2em">有可能你做出错误的归因，但在很大程度上能够调整你的情绪。我们很多关于这个世界的思考是自动地、无意识地进行的，因此情绪的二因素理论在事情发生时很难体会到，但事实就是如此，当一件事持续很久时，你就是在不断的做情绪唤起的归因来调整自己。</p><p style="text-indent:2em">因此，某件事情影响了你的情绪后，可以试着去分析当前的情绪是如何被唤起的，这个将帮助你有个更好的生活状态。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;当情感说话时，理智很少不听从。         ——Milan Kundera&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="生活" scheme="http://JohnneyAnn.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://JohnneyAnn.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="心理学" scheme="http://JohnneyAnn.github.io/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>用经济学的头脑想问题-沉没成本</title>
    <link href="http://JohnneyAnn.github.io/2017/09/08/Think%20in%20Economics/"/>
    <id>http://JohnneyAnn.github.io/2017/09/08/Think in Economics/</id>
    <published>2017-09-08T13:04:23.458Z</published>
    <updated>2017-09-08T13:04:23.450Z</updated>
    
    <content type="html"><![CDATA[<p>我并不懂经济学，因为巧合看了一本书，书的简介中说道：“融生活与经济原理与一体，让你更加理性的认识生活，更加准确的把握生活的内在”，索性看了下去。</p><p>这本书叫《一本书看懂经济学》，作者是庆裕。</p><a id="more"></a><h2 id="我对这书的看法"><a href="#我对这书的看法" class="headerlink" title="我对这书的看法"></a>我对这书的看法</h2><p>书的评价并不算好，大都是因为说这本书讲的基础，但可能这也是好处，日常经济学概念用生活实例来解读，也算简单易懂，适合入门。</p><p>我把它当作科普读物。</p><h2 id="有些不错的概念"><a href="#有些不错的概念" class="headerlink" title="有些不错的概念"></a>有些不错的概念</h2><p>书中介绍了很多经济学的概念，看到“沉没成本”这个概念时，我决定把它写下来分享给大家。</p><p>因为，这样的情况我们会经常遇见。</p><h3 id="覆水不必收-沉没成本"><a href="#覆水不必收-沉没成本" class="headerlink" title="覆水不必收-沉没成本"></a><center>覆水不必收-沉没成本</center></h3><p>书中说了这样一个故事。<br>有一个老人特别喜欢收集各种古董，一旦碰到心爱的古董，无论花多少钱都要想方设法把它买下来。有一天，他在古董市场上发现了一件向往已久的古代瓷瓶，就花了很高的价钱把它买了下来。 </p><p>他把这个宝贝绑在自行车后座上，兴高采烈地骑车回家，谁知由于瓷瓶绑得不牢靠，在途中从自行车后座上滑落下来，“咣当”一声摔得粉碎。 </p><p>这位老人听到清脆的响声后居然连头也没回继续骑车。这时，路边有热心人对他大声喊道：“老人家，你的瓷瓶摔碎了！”老人仍然是头也没回地说：“摔碎了吗？听声音一定是摔得粉碎，无可挽回了！”不一会儿，老人家的背影消失在了茫茫人海中。</p><p>如果这种事情放到一般人的身上，一定会从自行车上跳下来，对着已经化为碎片的瓷瓶捶胸顿足，扼腕痛惜，有的可能会好长时间精神都难以恢复。</p><p>每一次选择之后，我们总是要付出行动，而每一次行动我们总是要作出投入，不管投入的是人力、物力、财力还是时间。在作出下一个选择时，我们不可避免地会考虑到这些前期的投入，不管它还能不能收回，是否真的还有价值。最终，前期的投入就像万能胶一样，把我们粘在原来的道路上，无法作出新的选择，而且投入越大，把我们粘得越紧。在经济学上这种无法收回的前期投入叫做沉没成本。沉没成本是指由于过去的决策已经发生了，而不能由现在或将来的任何决策改变的成本。</p><p>也就是说，沉没成本是种已经付出但又不能收回的成本。</p><p>对于个人来说，不计沉没成本也反映了一种向前看的心态。通常情况下，人们在决定是否继续去做一件事情的时候，不仅看重这件事对自己有没有好处，而且也看过去是不是已经在这件事情上有过投入。他们往往会计算已有支出，如时间、金钱、精力等。其实当我们面对无可挽回的损失，就应该对它不再考虑，那么我们一定能在人生的道路上不断地作出新的选择，赢得一种更为积极的人生。</p><h2 id="臣服与事实"><a href="#臣服与事实" class="headerlink" title="臣服与事实"></a>臣服与事实</h2><p>我们身边会发生各种各样的事，当某些事已成为事实，我们需要学会臣服。事实无法去改变，你所做的试图去改变的都是徒劳。我们应当理性的去看待，从中汲取经验向前看，让还没有发生的事有自己想要的结局。</p><p>希望这个观点能够对你有帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我并不懂经济学，因为巧合看了一本书，书的简介中说道：“融生活与经济原理与一体，让你更加理性的认识生活，更加准确的把握生活的内在”，索性看了下去。&lt;/p&gt;
&lt;p&gt;这本书叫《一本书看懂经济学》，作者是庆裕。&lt;/p&gt;
    
    </summary>
    
      <category term="书籍分享" scheme="http://JohnneyAnn.github.io/categories/%E4%B9%A6%E7%B1%8D%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="经济学" scheme="http://JohnneyAnn.github.io/tags/%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>社会心理学-解释某些社会行为</title>
    <link href="http://JohnneyAnn.github.io/2017/09/08/Social%20Psychology%20-%20Interpreting%20certain%20social%20behaviors/"/>
    <id>http://JohnneyAnn.github.io/2017/09/08/Social Psychology - Interpreting certain social behaviors/</id>
    <published>2017-09-08T13:04:08.062Z</published>
    <updated>2017-09-08T13:04:08.050Z</updated>
    
    <content type="html"><![CDATA[<p>社会心理学定义为探讨人们的思维、情感及行为如何因他人真实或想象的存在而受到影响的科学研究。个人认为社会心理学，能够有效的解释某些社会行为，理性的看待某些行为能够有效的进行情绪控制。</p><p>今天推荐的这本书是《社会心理学》，作者是Aronson et al.</p><a id="more"></a><h2 id="社会心理学与人格心理学"><a href="#社会心理学与人格心理学" class="headerlink" title="社会心理学与人格心理学"></a>社会心理学与人格心理学</h2><p>这是心理学两个不同的分支，人格心理学倾向于从人的人格或者说性格来考虑，比如会说，这个人因为是这样的性格所以才会做出那样的事。而社会心理学则是从人物所处在的社会情境来考虑，因为这个人有着这样的环境所以才会做出那样的事。</p><p>我更倾向与社会心理学，个人愚见，一个人的人格是由他所处在的环境影响的，人格心理学容易犯基本归因错误，一昧的归因于人物性格而忽略社会情境对人的影响。</p><p>下面介绍下我觉得不错的有帮助的内容。</p><h2 id="行为的两个基本需求"><a href="#行为的两个基本需求" class="headerlink" title="行为的两个基本需求"></a>行为的两个基本需求</h2><h3 id="自尊取向：保持良好感觉的需要"><a href="#自尊取向：保持良好感觉的需要" class="headerlink" title="自尊取向：保持良好感觉的需要"></a><center>自尊取向：保持良好感觉的需要</center></h3><p>希望维持合理的高自尊，人们为了有好的自我形象而扭曲世界，为自己的行为辩护。例如当你的考试考砸了，你更倾向于找一些客观的原因使得自己处在有利的地位。</p><p>补充一点：人们倾向于认为成功是由于自己的努力，而将失败归咎于不可控制的外在事件。</p><h3 id="社会认知取向：对准确性的需求"><a href="#社会认知取向：对准确性的需求" class="headerlink" title="社会认知取向：对准确性的需求"></a><center>社会认知取向：对准确性的需求</center></h3><p>即使人们会尽可能扭曲真相以使自己处在一个有利的位置，但并不会完全扭曲事实活在一个梦幻的世界。</p><h2 id="自证预言"><a href="#自证预言" class="headerlink" title="自证预言"></a>自证预言</h2><p>这个我们经常会遇见，对第一次见面的人，我们会根据我们以往的图式来赋予这个人对我们的第一印象，这样的预期会影响我们如何对待他，而这种对待方式又会导致那个人的行为与我们最初的预期一致，使得这一预期成为现实，而事实上他可能跟我们想的完全相反，但由于你这样对他，他以牙还牙产生了现在的结局。</p><h2 id="归因过程的本质"><a href="#归因过程的本质" class="headerlink" title="归因过程的本质"></a>归因过程的本质</h2><p>书中归因的例子可推出下面的结论。</p><p>当二者关系较好时，对于对方的正性行为作内部归因（比如，“他之所以帮助我，是因为他是一个非常慷慨的人”），而对对方的负性行为作外部归因（比如，“他之所以说些刻薄的话，是因为他的工作实在太紧张了”），反之，则采取相反的模式。</p><p>懂得这个我想可以更好的处理人际关系。</p><h2 id="最后说一下探照灯效应"><a href="#最后说一下探照灯效应" class="headerlink" title="最后说一下探照灯效应"></a>最后说一下探照灯效应</h2><p>这大概算是给我们经常出现的状况取了个名字。</p><p>探照灯效应是指高估自己的行为和外表在他人眼中的显著程度的倾向。</p><p>正是因为这种效应，我们才会对自己的不是之处感到尴尬和担忧（这通常高于必要水平）。<br>举几个例子吧，像是今天发型不太好，走路一不小心摔倒了，课堂上回答了自认为很愚蠢的话，这些都会让我们觉得尴尬，而尴尬的原因来自于他人，觉得别人会注意到，会嘲笑等等。</p><p>其实啊，很多时候别人根本没有注意那么多！人家没事老注意你干嘛，别自恋了。实验结果证明也如此。</p><p>请放松，也许你今天的发型很糟糕，但很可能没有其他人注意到。</p><h2 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h2><p>这本书很长，这里当记个笔记，后面再继续分享。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;社会心理学定义为探讨人们的思维、情感及行为如何因他人真实或想象的存在而受到影响的科学研究。个人认为社会心理学，能够有效的解释某些社会行为，理性的看待某些行为能够有效的进行情绪控制。&lt;/p&gt;
&lt;p&gt;今天推荐的这本书是《社会心理学》，作者是Aronson et al.&lt;/p&gt;
    
    </summary>
    
      <category term="书籍分享" scheme="http://JohnneyAnn.github.io/categories/%E4%B9%A6%E7%B1%8D%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="心理学" scheme="http://JohnneyAnn.github.io/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>印象管理</title>
    <link href="http://JohnneyAnn.github.io/2017/09/08/Impression%20management%20the%20world%20is%20a%20big%20stage/"/>
    <id>http://JohnneyAnn.github.io/2017/09/08/Impression management the world is a big stage/</id>
    <published>2017-09-08T13:03:50.922Z</published>
    <updated>2017-09-08T13:03:50.906Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>印象管理:世界是个大舞台<br>我们都像舞台上的演员，尽力地要让“观众”（我们周围的人）相信自己是某种人，即使其实我们并非这种人。</p></blockquote><a id="more"></a><h2 id="什么是印象管理"><a href="#什么是印象管理" class="headerlink" title="什么是印象管理"></a>什么是印象管理</h2><p style="text-indent:2em">印象管理：人们试图让他人以自己期望的方式来看待自己。</p><p style="text-indent:2em">若想让别人以自己的期望来看待自己，那作为演员的我们就得演。如何演是印象管理的策略，这里说一个策略叫“自我妨碍”。</p><h2 id="什么是自我妨碍"><a href="#什么是自我妨碍" class="headerlink" title="什么是自我妨碍"></a>什么是自我妨碍</h2><p style="text-indent:2em">自我妨碍：人们为自己制造障碍和借口，以便在表现不佳时避免自责的策略。</p><h3 id="自我妨碍的两个方法"><a href="#自我妨碍的两个方法" class="headerlink" title="自我妨碍的两个方法"></a>自我妨碍的两个方法</h3><p style="text-indent:2em">第一种比较极端：人们故意制造障碍来减少自己成功的可能性，这样如果失败了，他们就会归罪于这些障碍，而不是自己缺乏能力。</p><p style="text-indent:2em">第二种没有那么极端：与创造障碍不同，人们会事先准备好理由以防止万一出现的失败，比如心情不好、紧张、身体不适等等。</p><h3 id="得到的结论"><a href="#得到的结论" class="headerlink" title="得到的结论"></a>得到的结论</h3><p style="text-indent:2em">总之自我妨碍就是人们对自己的失败做一个外部归因来向别人解释自己的表现，以转变他们可能对你进行的负性的内部归因（比如就是你就是不行啊- -）。</p><p style="text-indent:2em">所以啊，人们最好是努力学习并尽自己最大的努力，而不要太在乎自己失败后别人会怎么想。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;印象管理:世界是个大舞台&lt;br&gt;我们都像舞台上的演员，尽力地要让“观众”（我们周围的人）相信自己是某种人，即使其实我们并非这种人。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="生活" scheme="http://JohnneyAnn.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://JohnneyAnn.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="心理学" scheme="http://JohnneyAnn.github.io/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>我现在已不敢往后想</title>
    <link href="http://JohnneyAnn.github.io/2017/09/08/I%20can&#39;t%20think%20back%20now/"/>
    <id>http://JohnneyAnn.github.io/2017/09/08/I can&#39;t think back now/</id>
    <published>2017-09-08T13:03:30.994Z</published>
    <updated>2017-09-08T13:03:30.986Z</updated>
    
    <content type="html"><![CDATA[<p>任何事都是两面的，人们对一件事有着正面的解释，自然别人会给它另一种解释。各自都有道理。</p><p>对于该不该畅想未来这件事，我想别人也有两种看法，我的看法在转变。</p><a id="more"></a><p>人应该思考未来，好让自己知道想要的未来是什么样的，自己也有了目标，一切好似有了奔头，如果你真的在做准备，渴望去达到你所设定的目标，那么你肯定会尝到甜头。觉得这一切做的都是值得的，这是希望。</p><p>人不需要思考未来，应当过好当前的生活，未来就会来。谁也不能保证未来会是什么样子，未来到来之时，它是什么样子取决于你在那时内心的映射，未来“好”的标准来源于你自己而不是别人。既然这样，何必那么多期望，应该让现在的自己开心。期望抬的越大，摔的越惨，这是绝望。</p><p>如何得到幸福感？拥有更多的钱？有个大房子？是否物质上的满足真的能让人感到幸福?</p><p>没错，能。</p><p>但这种幸福感是短暂，当你渴望去得到某样的东西的时候，享受的是其中的过程，真的得到了这个过程就过了。那一直去追求不就好了？尴尬的就在这，人们得去做有把握的事，得不到又会很失望。、</p><p>是否可以这样，物质上的追求转变为生活上的追求，让自己的生活变得有趣。人总不能不追求，精神追求是能够提高自己的社会认知的，碎片化时代我们需要不断的学习，去多了解一些事物。38平的房子照样可以装出自己想要的样子，住的舒坦不就行了，空闲的时间多看看书，多出去走走去了解其他地方的文化，充实自己。必须承认社会是现实的，但我们学到的不是变的现实，而去接受现实，理解现实。如何去支撑这些想法呢，你还是要努力工作啊，工作也是生活的一部分，不用去追求别人追求的，选择你想要的生活，如果工作也是自己喜欢的，甚是完美。</p><p>我一直在思考未来，而现在我已经不敢往后想。你在思考的时候，是你正在为自己选择路线，是在社会影响下选择的路线，别人都说这条路不错，于是你也准备走走，因为在这种时候，人们用于对自己的真实想法进行误判。路很长，可恨的是，一开始我们真的不偏不移的走着，掉以轻心，以至于没有预计到当前面的路出现一点点的误差时自己该如何应对。有的可能是致命的，让自己在自己的幻想中死去。</p><p>罢了，别想了。何必这么折腾，我在改变我的想法，我想过好现在的生活，我想去体验生活。</p><p>那么，未来该怎么办？套用软件行业的一个思想：拥抱变化，积极应对。</p><p>一直觉得，我们应当在大环境下“顺其自然”，因为顺其自然才是可持续发展，在小环境下努力向上，做好每一件事。顺道而不失道，无为而有所谓，再等等，慢一点，总会来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;任何事都是两面的，人们对一件事有着正面的解释，自然别人会给它另一种解释。各自都有道理。&lt;/p&gt;
&lt;p&gt;对于该不该畅想未来这件事，我想别人也有两种看法，我的看法在转变。&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://JohnneyAnn.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://JohnneyAnn.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="愚见" scheme="http://JohnneyAnn.github.io/tags/%E6%84%9A%E8%A7%81/"/>
    
  </entry>
  
  <entry>
    <title>Docker初体验</title>
    <link href="http://JohnneyAnn.github.io/2017/09/08/DockerInitialExperience/"/>
    <id>http://JohnneyAnn.github.io/2017/09/08/DockerInitialExperience/</id>
    <published>2017-09-08T13:01:33.775Z</published>
    <updated>2017-09-08T13:01:33.771Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。<br><a id="more"></a></p><h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><h3 id="保证Ubuntu软件源最新"><a href="#保证Ubuntu软件源最新" class="headerlink" title="保证Ubuntu软件源最新"></a>保证Ubuntu软件源最新</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ apt-get update</div></pre></td></tr></table></figure><p>当前系统为Ubuntu16x64，root用户</p><h3 id="下载-docker"><a href="#下载-docker" class="headerlink" title="下载 docker"></a>下载 docker</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ apt-get install -y docker.io</div></pre></td></tr></table></figure><p>下载完成后可使用docker version查看docker版本，正常会显示client以及server，由于未启动docker服务，此时只会显示client的信息，可执行第三步启动docker，再执行docker version即可正常显示，显示结果如下<br><img src="/img/docker/dockerinfo.png" alt="docker信息"></p><h3 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ service docker start</div></pre></td></tr></table></figure><h3 id="拉取docker官网的镜像hello-world-名字需一致"><a href="#拉取docker官网的镜像hello-world-名字需一致" class="headerlink" title="拉取docker官网的镜像hello-world(名字需一致)"></a>拉取docker官网的镜像hello-world(名字需一致)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker pull hello-world</div></pre></td></tr></table></figure><h3 id="至此可查看镜像列表"><a href="#至此可查看镜像列表" class="headerlink" title="至此可查看镜像列表"></a>至此可查看镜像列表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker images</div></pre></td></tr></table></figure><h3 id="运行hello-world（前台运行）"><a href="#运行hello-world（前台运行）" class="headerlink" title="运行hello-world（前台运行）"></a>运行hello-world（前台运行）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run hello-world</div></pre></td></tr></table></figure><p>运行结果如下图所示，从内容可看到hello-world的运行做了哪些事：<br><img src="/img/docker/hello.png" alt="hello-world"></p><h2 id="来试试其他镜像吧"><a href="#来试试其他镜像吧" class="headerlink" title="来试试其他镜像吧"></a>来试试其他镜像吧</h2><p>由于docker官网的镜像下载较慢，这里通过<a href="https://c.163.com/" target="_blank" rel="external">网易蜂巢中心</a>拉取镜像</p><h3 id="拉取nginx镜像"><a href="#拉取nginx镜像" class="headerlink" title="拉取nginx镜像"></a>拉取nginx镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker pull hub.c.163.com/library/nginx:latest</div></pre></td></tr></table></figure><h3 id="后台运行nginx"><a href="#后台运行nginx" class="headerlink" title="后台运行nginx"></a>后台运行nginx</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run -d hub.c.163.com/library/nginx</div></pre></td></tr></table></figure><p>后台运行将返回一个id，如：6b79dde…..</p><p>docker run –help 可查看可选的参数，-d参数表示后台运行</p><h3 id="查看运行的容器"><a href="#查看运行的容器" class="headerlink" title="查看运行的容器"></a>查看运行的容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker ps</div></pre></td></tr></table></figure><p><img src="/img/docker/dockerps.png" alt="docker进程"></p><h3 id="当然可以进入容器内部"><a href="#当然可以进入容器内部" class="headerlink" title="当然可以进入容器内部"></a>当然可以进入容器内部</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker <span class="built_in">exec</span> -it 6b /bin/bash</div></pre></td></tr></table></figure><p>（6b为id简写，如果很容易识别id可以简写）</p><p>容器就像是一个虚拟的机器，进入后和linux没有区别，我把它就看成虚拟机了- -</p><h3 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">exit</span></div></pre></td></tr></table></figure><h2 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h2><p>部署项目当然需要进行外部访问，因此需要将当前机器与容器进行端口映射</p><p>我们先关闭nginx容器来便于后边的操作</p><h3 id="关闭nginx"><a href="#关闭nginx" class="headerlink" title="关闭nginx"></a>关闭nginx</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker stop 6b</div></pre></td></tr></table></figure><h3 id="以桥接Bridge的方式启动nginx"><a href="#以桥接Bridge的方式启动nginx" class="headerlink" title="以桥接Bridge的方式启动nginx"></a>以桥接Bridge的方式启动nginx</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run -d -p 9999:80 hub.c.163.com/library/nginx</div></pre></td></tr></table></figure><p>其实就是配置端口映射，使用参数-p,具体端口可按实际需求指定</p><p>还有种映射方式，随机端口映射（使用参数-P），将映射容器的所有端口,我一般用第一种<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run -d -P hub.c.163.com/library/nginx</div></pre></td></tr></table></figure></p><h3 id="查看端口是否启动"><a href="#查看端口是否启动" class="headerlink" title="查看端口是否启动"></a>查看端口是否启动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ netstat -na|grep 9999</div></pre></td></tr></table></figure><h3 id="现在就可以访问啦"><a href="#现在就可以访问啦" class="headerlink" title="现在就可以访问啦"></a>现在就可以访问啦</h3><p>去浏览器输入你的服务器ip配上刚刚的9999端口号就ok了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">IP:9999</div></pre></td></tr></table></figure><p><img src="/img/docker/nginx.png" alt="nginx"></p><h2 id="自定义镜像"><a href="#自定义镜像" class="headerlink" title="自定义镜像"></a>自定义镜像</h2><p>这才是最重要的吧，自己写的项目如何用docker部署？</p><p>这里以Jpress为例吧，顺便说一下mysql部署</p><h3 id="下载jpress的war包"><a href="#下载jpress的war包" class="headerlink" title="下载jpress的war包"></a>下载jpress的war包</h3><p>进入<a href="http://jpress.io/" target="_blank" rel="external">Jpress官网</a>,点击下载跳转到github下载最新的war包：<br><img src="/img/docker/jpress.png" alt="jpress"></p><p>下载完成后防止到某个文件夹（如/home/username）,为了方便 重命名war包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mv jpress-web-newest.war jpress.war</div></pre></td></tr></table></figure><h3 id="拉取tomcat镜像"><a href="#拉取tomcat镜像" class="headerlink" title="拉取tomcat镜像"></a>拉取tomcat镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker pull hub.c.163.com/library/tomcat:latest</div></pre></td></tr></table></figure><p>因为要部署到tomcat中去，所以也拉个下来，tomcat镜像是自带JDK的，所以无需拉取java的镜像了</p><h3 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vim Dockerfile</div></pre></td></tr></table></figure><p>Dockerfile就创建镜像的文件啦，若不在当前文件夹下，注意文件引入的路径</p><h3 id="填写内容"><a href="#填写内容" class="headerlink" title="填写内容"></a>填写内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">from hub.c.163.com/library/tomcat</div><div class="line"></div><div class="line">MAINTAINER anyang  johnney**@163.com</div><div class="line"></div><div class="line">COPY jpress.war /usr/<span class="built_in">local</span>/tomcat/webapps</div></pre></td></tr></table></figure><p>解释一下：这是基本配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">from 引入tomcat镜像</div><div class="line"></div><div class="line">MAINTAINER 镜像的所有者及联系方式，可不填</div><div class="line"></div><div class="line">COPY 将创建的镜像拷贝到tomcat下，tomcat的具体路径可在镜像中心的镜像详情查看</div></pre></td></tr></table></figure><h3 id="构建自定义镜像"><a href="#构建自定义镜像" class="headerlink" title="构建自定义镜像"></a>构建自定义镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker build -t jpress:latest .</div></pre></td></tr></table></figure><p>-t镜像名字及TAG  后面参数为镜像目录，.代表当前目录</p><p>创建完成后可查看自己的镜像：（docker images）</p><h3 id="运行自定义镜像"><a href="#运行自定义镜像" class="headerlink" title="运行自定义镜像"></a>运行自定义镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run -d -p 8888:8080 jpress</div></pre></td></tr></table></figure><h3 id="拉取mysql镜像"><a href="#拉取mysql镜像" class="headerlink" title="拉取mysql镜像"></a>拉取mysql镜像</h3><p>由于Jpress的安装需要使用到数据库，因此有了下面的步骤</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker pull hub.c.163.com/library/mysql:latest</div></pre></td></tr></table></figure><h3 id="运行mysql镜像"><a href="#运行mysql镜像" class="headerlink" title="运行mysql镜像"></a>运行mysql镜像</h3><p>运行mysql是需要配置些数据库信息，如数据库密码（MYSQL_ROOT_PASSWORD）、需要创建的数据库（MYSQL_DATABASE）等，使用-e参数配键值对，更多参数可在镜像中心mysql镜像详情中查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run -d -p 7777:3306 -e MYSQL_ROOT_PASSWORD=000000 -e MYSQL_DATABASE=jpress hub.c.163.com/library/mysql</div></pre></td></tr></table></figure><h3 id="配置并重启jpress容器"><a href="#配置并重启jpress容器" class="headerlink" title="配置并重启jpress容器"></a>配置并重启jpress容器</h3><p>按照上面的参数以及Jpress页面提示的安装步骤，填写好相应的信息即可成功创建Jpress。</p><p>配置完成后，需要重启jpress容器（按照你的具体id）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker restart 5e8caebf1643</div></pre></td></tr></table></figure><h3 id="OK-访问吧"><a href="#OK-访问吧" class="headerlink" title="OK 访问吧!"></a>OK 访问吧!</h3><p>在浏览器输入IP:8888/jpress,结果如下</p><p><img src="/img/docker/jpresspage.png" alt="jpress页面"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="http://JohnneyAnn.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="docker" scheme="http://JohnneyAnn.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Ajax跨域问题</title>
    <link href="http://JohnneyAnn.github.io/2017/09/08/AjaxCrossDomain/"/>
    <id>http://JohnneyAnn.github.io/2017/09/08/AjaxCrossDomain/</id>
    <published>2017-09-08T13:00:59.407Z</published>
    <updated>2017-09-08T13:00:59.399Z</updated>
    
    <content type="html"><![CDATA[<p>由于JS同源策略的影响，因此js只能访问同域名下的文档，当我们用ajax请求某个别人提供的接口时，可能存在跨域问题，导致接口无法访问，这里有一些解决方案。</p><a id="more"></a><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>百度的解释：</p><blockquote><p>同源策略，它是由Netscape提出的一个著名的安全策略。现在所有支持JavaScript 的浏览器都会使用这个策略。所谓同源是指，域名，协议，端口相同。当一个浏览器的两个tab页中分别打开来 百度和谷歌的页面当一个百度浏览器执行一个脚本的时候会检查这个脚本是属于哪个页面的，即检查是否同源，只有和百度同源的脚本才会被执行。</p></blockquote><h2 id="跨域报错信息"><a href="#跨域报错信息" class="headerlink" title="跨域报错信息"></a>跨域报错信息</h2><pre><code>Origin null is not allowed by Access-Control-Allow-Origin</code></pre><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="在服务端填上响应头"><a href="#在服务端填上响应头" class="headerlink" title="在服务端填上响应头"></a>在服务端填上响应头</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); </div><div class="line">response.setHeader(&quot;Access-Control-Allow-Methods:GET,POST&quot;);</div></pre></td></tr></table></figure><p>*号表示所有的域都接受，HTML5中提供的XMLHTTPREQUEST Level2（即XHR2）已经实现了跨域访问，添加上这些即可。</p><p>目前遇到的一个跨域问题使用这个方法解决了，只添加了第一条。</p><h2 id="另一种解决方案"><a href="#另一种解决方案" class="headerlink" title="另一种解决方案"></a>另一种解决方案</h2><h3 id="JSONP-JSON-with-Padding"><a href="#JSONP-JSON-with-Padding" class="headerlink" title="JSONP(JSON with Padding)"></a>JSONP(JSON with Padding)</h3><p>JSONP还需要去理解，这里先记个笔记，可无视。。。不保证记录的正确性。</p><p>百度百科</p><blockquote><p>JSONP(JSON with Padding)是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。用 JSONP 抓到的资料并不是 JSON，而是任意的JavaScript，用 JavaScript 直译器执行而不是用 JSON 解析器解析。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;  </div><div class="line">   url: &quot;http://异域IP:port/getSomeData.do&quot;,  </div><div class="line">   dataType: &quot;jsonp&quot;,  </div><div class="line">   jsonpCallback: &quot;callbank&quot;,  //设置一个回调函数，请求的JSON将会被包裹在callback()内</div><div class="line">   success: function(data) &#123;</div><div class="line">//...</div><div class="line">&#125;  </div><div class="line">&#125;);  </div><div class="line">function callbank(data) &#123;  </div><div class="line">    console.log(data);  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>JSONP对于GET适用，对于POST并没有完美支持，也需在服务端添上相应头，下面两行代码都需要。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;); </div><div class="line">response.setHeader(&quot;Access-Control-Allow-Methods:GET,POST&quot;);</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于JS同源策略的影响，因此js只能访问同域名下的文档，当我们用ajax请求某个别人提供的接口时，可能存在跨域问题，导致接口无法访问，这里有一些解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://JohnneyAnn.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://JohnneyAnn.github.io/tags/Java/"/>
    
      <category term="jQuery" scheme="http://JohnneyAnn.github.io/tags/jQuery/"/>
    
      <category term="Ajax" scheme="http://JohnneyAnn.github.io/tags/Ajax/"/>
    
      <category term="编程问题" scheme="http://JohnneyAnn.github.io/tags/%E7%BC%96%E7%A8%8B%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>来自南京眼</title>
    <link href="http://JohnneyAnn.github.io/2017/09/02/%E6%9D%A5%E8%87%AA%E5%8D%97%E4%BA%AC%E7%9C%BC/"/>
    <id>http://JohnneyAnn.github.io/2017/09/02/来自南京眼/</id>
    <published>2017-09-01T16:47:33.639Z</published>
    <updated>2017-09-01T16:47:33.631Z</updated>
    
    <content type="html"><![CDATA[<p>2017.9.1 23:24</p><br><p>耽误了两周，但说要去还是要去的啊。当时觉得先去近一点的地方，选择了南京眼，是在网上看的照片，自己也喜欢水，那在桥上走着肯定很舒服。周五晚上去是很合适的。</p><br><a id="more"></a><br><p>当然，以上的想法或者说是计划是对于我一个人的。事实上并不是，好友来访，可能是猜到我昨天发了工资（狗贼！），索性就带他一起去吧，不，还有他女朋友（我是拒绝的！）。就这样开始了两个人和一条狗的短途。</p><br><p>我们是先做地铁到江心洲，随后叫的滴滴。下车的地方是一个小道，很长的小道，能够从远处看到南京眼的小道。顺着小道，朝桥的方向走去，小道是有路灯的，人不太多，可能都在桥上。这个时候已经有微风袭来，我喜欢走在前面，打开网易云音乐放了首Eason的《心的距离》，快步的走着。</p><br><p>到了桥上，灯光很好看，能够看到远处的大厦，这是我想到的城市该有的样子，所以我想我也是喜欢这个地方的。不拍照肯定不合适，我拍着景色，他们在自拍，或许也拍了这美景。可能是知道我晚上吃的不太饱，体贴的他们一把一把的狗粮往我嘴里塞，我享受着美食。（不要脸！）这不是重点，终于到了最尴尬的时候，我需要完成作为单手狗的使命，给他们拍照。我蹲在地下，满足他们的各种要求，像是“别拍腿”，“拍我亲他”，周围的人在我旁边走过，我仍蹲在地下等别人走再拍。喂！单身狗支架不要尊严啊！</p><br><p>上面都是玩笑话，能够看着朋友们开开心心，心里也算欣慰。他俩呢也是我之前说的有问题的情侣中的一对，有问题是我本着学习社会心理学应该学以致用的想法来分析他们之间的矛盾所得出来的结论。希望能够帮助他们去理解矛盾，遇到问题也能够想着尽力去解决，倒不希望他们走我走过的路。我喜欢去分析，可分析到最后得到结论与我自己的预见是不一致的。每个人都有自己的烦恼，两个人在一起自然会有矛盾，就你现在看到的他们的样子，你凭什么说他们有问题？作为局外人，我们自认能够看到他们组成的系统中所存在的问题，然而当这个系统出现紊乱（矛盾）时，系统的自我调节正是在加强这个系统的稳定性，自我调节的来源于哪？来自于系统成员自己的感悟、自己的行动。可以去分析当前的矛盾的原因，但主体不是你这个局外人。所以啊，明白了这个之后，想想自己瞎操个什么心啊（摊手）。</p><br><p>这里，比作一个系统的话，那自然从中体会到的是道家的思想，个人愚见，各学说中道家是最具科学依据的。旁观者，即是将我们抽离系统之外，或者对于某个系统来说我们极其渺小。那系统的稳定与否应当是顺其自然的，用外力去影响这个系统是有悖于道的。作为局外者，对于由别人组成的系统，或者对于自然这个大系统，它们有自己存在的方式，有自己调节的方式，我们干涉不了，能够自我调节的系统是适于万物的规律的，否则这个系统自然是不适合的，那么，瓦解也未尝不可。让他们自己发展，我们并不是圣人，能够处理好自己的事已实属不易。</p><br><p>既然是短途，到了时间也该结束了，但这次的出行自认为还是有意义的。不敢说什么能够以小见大能够看透什么，但希望能够做一个格物致知的人。到这，也能够去理解，人们为什么爱好去旅行，旅行不是到一个地点拍张照片告诉别人自己来过这个地方，而是我们需要遇见更多的人，去看更大的世界，能够去找到反省自己找到真我，让自己的认知得到提升，这才是旅行的意义。</p><br><p>通过认识别人来认识自己。我的想法是以当前为一个原点，小范围的一步步向外扩撒，以时间为刻度扩大自己周围的空间，在以后的日子多去一些地方，去实现自己的想法，共勉。</p><br><p>哎呀，这本来是想写下单身狗被虐的过程的，感觉。。。跑题了啊（尴尬脸）！罢了罢了，不重要，就是个噱头，谁说我像条狗的？我是个有梦想的程序猿好吧！我想我写的是我认为重要的。</p><br><p>睡了睡了，明天去加班，晚上还得去找虐！我得好好休息。</p><br><p>2017.9.2 00:41</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017.9.1 23:24&lt;/p&gt;&lt;br&gt;&lt;p&gt;耽误了两周，但说要去还是要去的啊。当时觉得先去近一点的地方，选择了南京眼，是在网上看的照片，自己也喜欢水，那在桥上走着肯定很舒服。周五晚上去是很合适的。&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://JohnneyAnn.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://JohnneyAnn.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>我还有心事没解决</title>
    <link href="http://JohnneyAnn.github.io/2017/08/26/%E6%88%91%E8%BF%98%E6%9C%89%E5%BF%83%E4%BA%8B%E6%B2%A1%E8%A7%A3%E5%86%B3/"/>
    <id>http://JohnneyAnn.github.io/2017/08/26/我还有心事没解决/</id>
    <published>2017-08-25T16:24:21.012Z</published>
    <updated>2017-08-25T16:24:21.012Z</updated>
    
    <content type="html"><![CDATA[<p>2017.8.25 23:25</p><br><p>这周给自己顶了一个计划，关于睡眠时间的。23点-6点周一是这样执行的，周二发现不可抗因素太多，当你把这一天所需要干完的事做完，23点是不够的。于是就变成了24点-7点。当然，仍没有计划的好。</p><br><a id="more"></a><br><p>24点到准时关灯，想让自己睡下。发现躺下脑海里全是事，有工作，有回忆，也有在意淫。这周一直在做一个关系图的展示，自然晚上也会去思考某一个功能应该去怎么实现，怎么去优化。还有就是能够想到一些之前的事，没有去想为什么会走到这一步，想的都是我是不是没有自己想象的那么放得下。</p><br><p>我有心事，我试着去放首轻松的歌来帮助自己入睡，强迫自己不去想，可闭上眼我能够看见我脑袋里出现的全是黑线，搅在一起的，密密麻麻。就又逼着自己去理顺它，内心是排斥的，是否给自己强加了太多的东西。无奈，我想去找一个理由去说服自己，能够不再逼自己。任何事情的发生都有一定的原因，任何事情的解决也都是因为我们自己找了能够让自己信服的理由，这是人类满足自尊的需求，让一切看似都是对的，让自己得到心理上的安慰。</p><br><p>该去何处找？我不知道。所以，我再给自己找个方式，来告诉自己这个方式能够去解决我当前的需求。于是，我做了个决定，周一请假，再去一次你的根，你之前待的地方，以后也会在。自认为这样能够解决我的心事。我有一个想法，把我们之前走过的路，去过的地方再走一遍，带上我自制的笔，每到一个地方，就画上一个句号，可能这会让我好受点。好像现在做的都在为我自己考虑，做的一切都是为了自己的需求，无妨，我确实自私，事实上也没有其他的办法。</p><br><p>先从你家开始吧。就想去走走，就只是走走，也不知道自己能不能忍住不去联系，我还记得你带我去的地方，我还想去见见它们，没准，它们也还记得我。上次去待的时间并不长，去一个地方所得到感受是与自己的心情有关的，那会是熟悉的，乐意的，渴望去到达的。现在的感受如同奔赴一个葬礼，害怕的，对距离感到恐惧的。我还是要去的，去接受才能继续往前走。</p><br><p>道理看的都明白，自己也会给别人说，但就是教不了自己。也明白朋友的安慰是出于对自己的关心，但确实，只有自己身处其中才发现并不易。因此，我表现出我的淡然，跟大家说我怎么的理性，怎么的能够很好的处理这些事，想省去朋友们的安慰，不毁坏他们的情绪。人去寻找在朋友间认同的需求事很重要的，但就目前看来，当认同的需求远小于自己身上的缺口时，是近似无效的，既然这样，自己去解决，别让他人担心。</p><br><p>新认识的一个朋友，可能在他认识我的时候我已经展示出跟以前不太一样的一面，而不像以前朋友对我的熟悉。那天我在看社会心理学，他问我：”像你这样的人，有什么能够干扰你？“。我何时变得如他嘴中说的那么强大？并没有。我看社会心理学并不是想去研究，我只是想用它来解释一些行为，将行为的感情色彩去除，才能让自己更容易去接受这些行为所给自己带来的影响。当然，我现在也不是什么都无所谓，我有我自己的想法，只是不愿意去把情绪放在对自己不利的事情上。我并不是无所畏惧，我有我的烦恼，但不一定得让别人知道，我需要去发泄，但发泄的对象不是非得是周围的人。我想他能明白我说的话。</p><br><p>我任性一次，周一请假去做自己想做的事。这周连续加了四晚上的班，明天再去把能够写完的写完，想多做一点，虽然还是不尽人意，没能将所有的工作完成。我把这周的工作进度写成邮件交给师傅，希望能够完成了下周一的交接，好让自己不那么感到失调，原谅自己。行吧，想做就做吧。</p><br><p>这次还有一个目的，在你的城市陪你过七夕。</p><br><p>也算”在一起“陪你过。</p><br><p>这是我最后的执着。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017.8.25 23:25&lt;/p&gt;&lt;br&gt;&lt;p&gt;这周给自己顶了一个计划，关于睡眠时间的。23点-6点周一是这样执行的，周二发现不可抗因素太多，当你把这一天所需要干完的事做完，23点是不够的。于是就变成了24点-7点。当然，仍没有计划的好。&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://JohnneyAnn.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://JohnneyAnn.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>我从未感受过的孤独</title>
    <link href="http://JohnneyAnn.github.io/2017/08/20/%E6%88%91%E4%BB%8E%E6%9C%AA%E6%84%9F%E5%8F%97%E8%BF%87%E7%9A%84%E5%AD%A4%E7%8B%AC/"/>
    <id>http://JohnneyAnn.github.io/2017/08/20/我从未感受过的孤独/</id>
    <published>2017-08-20T15:29:50.622Z</published>
    <updated>2017-08-20T15:29:50.622Z</updated>
    
    <content type="html"><![CDATA[<p>2017.8.20 22:52</p><br><p>今天是星期天。从昨晚开始，心里不太好受，我觉得是感受到了孤独。</p><br><p>我确实也是一个待不住的人，总爱折腾。</p><br><a id="more"></a><br><p>周六的晚上，我试图收拾东西来让自己有其他的事做，但还是无果，于是定了一张电影票区看了电影。好像是我第一次一个去看电影，后座的人好像很好奇，那个人怎么就一个人来看电影，这话之前我也说过。但当时还是想回头告诉她们：You are right,single me!haha…</p><br><p>我也能预计到到了周末我的状态，于是想给自己找点活动，回来后我在豆瓣上找适合我的活动，也去网上搜索南京还有哪些好玩的地方。于是准备去石塘竹海，号称南京的最后一块宝地，真正让我想去的原因是看了网上的照片。那个地方很美，在山中，有湖，有竹子，也有很多游玩的人。</p><br><p>于是我搜了下路线，38公里，一天的时间来不及，或者说去了只能看一眼，就放弃了。有空还是要去的，毕竟那么美，那么宁静，可能比较适合我。</p><br><p>我感受到我的焦虑。想找一些朋友问问他们周末有什么安排，或许可以带上我。找找一般周末有空的吧，先找南京的，阿亮不舒服。真不行去合肥也行啊，张靖睡了，阿兵工作太累了，也不想打扰，而且确实一天来回合肥实在是太赶。我凌乱了。</p><br><p>当初来南京，是带着对未来的幻想来的，合肥行业不景气，南京离家不太远相对来说不错，更大信念是她会在。如今，孤身一人在这个城市，我想我有点后悔了。一路走来，每做的一个决定都取决于当时所给予的条件，或者说前提，用那个前提来保证所做的决定是正确的。如今，前提丢失，那决定是否还无误？</p><br><p>今天的状态确实不太好，早上看了会代码发现并不专心，看了些知乎的帖子也能够清楚的认识到自己的不足，这也让我焦虑，得去解决。</p><br><p>傍晚去新街口、夫子庙，想去看看人，那边人真的很多啊，很热闹。我喜欢看人，他们有各种情绪，他们在笑我也偷偷扬扬嘴角，他们不开心我也知道每个人总有糟心的事，我在索取他们的情绪，我好像能够融入进去。是不是不算孤独？</p><br><p>人具有社会性，需要陪伴。我只身一人在这城市，何来陪伴？感受到孤独也是无可厚非的。除了每周的工作时间，其他时间事好像都是一个人，室友出差房子里也就一个人。我打点了下这个租来的家，一为了占用自己的时间，二也上这个租来的家真的有家的样子。</p><br><p>晚上准备早睡，定的是11点，辗转反侧，于是睡前还是把自己的情绪写下来发泄一番。我自认这是个很好的调节办法，也乐此不疲。</p><br><p>明早尝试着早起。晚安。我对自己说。</p><br><p>略显矫情。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017.8.20 22:52&lt;/p&gt;&lt;br&gt;&lt;p&gt;今天是星期天。从昨晚开始，心里不太好受，我觉得是感受到了孤独。&lt;/p&gt;&lt;br&gt;&lt;p&gt;我确实也是一个待不住的人，总爱折腾。&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://JohnneyAnn.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随笔" scheme="http://JohnneyAnn.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
